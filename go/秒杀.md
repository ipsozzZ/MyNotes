## # 秒杀流程


## # 秒杀开始前
1. 商品信息静态展示（包括库存信息），防止秒杀开始前流量激增导致 redis 缓存雪崩；
2. 开始前5分钟，服务端进行缓存预加载，防止 redis 缓存击穿；
3. 秒杀商品配置加载；


#### 库存查询
1. 秒杀开始前：客户端静态配置读取

2. 秒杀开始后：
   - 客户端缓存，玩家每1秒才能请求一次
   - 服务端：通过配置判断请求的秒杀商品id是否合法，防止缓存穿透
   - 服务端：请求数量限制40000，防止缓存雪崩
   - 服务端和客户端：每分钟玩家请求次数限制，防止部分请求饿死，导致客户端缓存严重滞后
   - 服务端：锁单后超时未购买的玩家禁止再次参与

#### 秒杀预扣库存
- 客户端缓存，玩家每1秒才能请求一次
- 服务端：通过配置判断请求的秒杀商品id是否合法，防止缓存穿透
- 服务端：请求数量限制40000，防止缓存雪崩
- 服务端和客户端：每分钟玩家请求次数限制，防止部分请求饿死，导致客户端缓存严重滞后
- 服务端：锁单后超时未购买的玩家禁止再次参与
- 分布式锁
- redis预扣
- 预扣完成


## # 秒杀逻辑 （crash safe 设计思路借鉴 mysql redolog 和 etcd wal日志）

1. redis 预扣库存成功后，通知客户端提示玩家，“正在全力抢单中” 避免客户端超时，也给玩家一个进度上的反馈，同时还能避免阻塞高并发的预扣流程（注意此时玩家并不知道自己抢到订单了）
2. 异步将玩家抢单成功的数据写入 mysql 数据库中（主要是充当 wal 的角色，利用 mysql 提供 crash safe 能力，做到对玩家锁单成功的持久承诺）
3. 第二步成功后，通知客户端玩家锁单成功，可以进行购买流程了，玩家秒杀流程进入 prepare 阶段（prepare状态 随着第二步同一个mysql事务写入mysql，用来异常情况后恢复时重放秒杀流程）
4. 玩家购买商品
5. 秒杀系统订阅订单消息，收到秒杀商品的订单时：将 mysql 中秒杀数据状态改为 finish，取消业务层超时逻辑


## # 数据库设计

redis 数据存在丢失的风险，所以数据库的需求是：可以存储玩家秒杀的状态，也可以在 redis 数据丢失后，通过 mysql 数据和秒杀商品配置来恢复 redis 商品剩余库存的数据，玩家购买后更新mysql数据的状态为完成，超时后更新状态为 timeout

1. 所以需要支持按秒杀商品id 快速查询所有状态不等于 timeout 的值
2. 根据商品id和玩家id快速更新数据

#### 玩家秒杀状态表设计细节

1. 方案一：玩家秒杀数据：使用自增主键，不管是查询秒杀商品还是查询玩家id时，都需要回表查询查询，效率一般。

2. 方案二：使用 (商品id, 玩家id) 作为联合主键，由于商品id是递增的int32，所以这个联合主键业务层能保证按顺序插入，可以避免频繁的数据库页分离情况，同时在业务层或者 redis 发生 crash 而丢数据需要恢复时，可以通过联合主键，根据商品id使用最左匹配原则，通过扫描主键和判断状态就能高效查询到所有处于 prepare 和 finish 状态的秒杀订单，能够快速重建 redis crash 前承诺给玩家的订单。

3. 方案二的弊端

上面方案二也可以使用普通联合索引或者两个字段分别建立普通索引，但都会导致回表，对 crash 恢复场景非常不利，但是因为mysql需要联合主键的保证唯一性，所以插入性能和更新性能相比自增主键明显下降


4. 解决方案

结合秒杀特点，还是选择方案二，首先这个表主要作用是用来应对业务层或者redis crash 的，以恢复性能优先；其次通过 redis 缓存库存预扣的拦截后，平均不到千分之一的请求才能到达 mysql，大大降低了 mysql 的写压力，而且是异步执行，不会阻塞客户端操作，综合考虑选择联合主键的方案二。

#### 表主要结构
```sql
DROP TABLE IF EXISTS `flash_sale`;
CREATE TABLE `flash_sale` (
                         `goods_id` INT(11) NOT NULL,
                         `user_id` BIGINT(20) NOT NULL,
                         `state` TINYINT NOT NULL default 0,
                         PRIMARY KEY (`goods_id`, `user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC;

一行数据大小：13字节：4字节 + 8字节 + 1字节

```


#### 秒杀系统 crash 后的恢复流程
1. 如果是业务层crash，只需要加载 redis 剩余库存到业务层缓存，在查询 mysql 秒杀状态表中状态是 prepare 的数据，业务层需要判断 crash 后恢复前，玩家是不是已经购买了商品，是就更新 mysql 数据状态，否则重新构建超时时间，恢复完成，如果 redis 数据丢失，则进行第二、第三步恢复数据；
2. 根据最左匹配原则查询得到：已完成和已锁单的秒杀商品数量；
3. 配置的秒杀商品数量 - 第二步的查询结果，就是剩余秒杀商品的库存，然后 写入 redis 即可，整个过程就可以恢复


## # 分布式锁设计

#### redis 锁
命令：set key val nx ex 1000

**1. lua脚本保证 set 和 ex 操作的原子性** 

否则 ex 执行失败就会导致 key 死锁

**2. val使用 userid + 业务标识，释放锁时需要校验**

否则可能会误删别人的锁，注意检验和删除也需要使用lua保证原子性，否则可能因为检查后删除前key过期，被其它客户端 set 了，导致误删

**3. 优点**

- 实现简单
- 性能最高


**3. 安全问题**

- 如果是单节点 redis 存在单点故障问题，即服务宕机后可能出现数据丢失
- 如果是主从集群，可能出现脑裂、换主时数据丢失等问题
- 需要业务层自己保证锁的公平性
- 需要业务层自己解决惊群效应问题


#### etcd 锁

**1. 核心机制**
- 租约（Lease）：为锁绑定一个租约，到期自动释放锁，避免死锁。
- 全局唯一 Revision：通过 etcd 的事务机制（Txn）和键的 Revision 实现锁的公平性和互斥性。
- Watch 监听：监听前一个持有锁的节点，实现阻塞等待。(可以避免惊群效应)

**2. 实现步骤**

尝试获取锁*：
   - 向 etcd 写入一个带租约的键（如 `/lock/resource1`）。
   - 通过事务判断写入的键是否为当前最小 Revision，若是则获得锁。

未获得锁：
   - 监听前一个 Revision 的键删除事件（通过 `Watch`），进入阻塞等待。

释放锁：
   - 删除键或让租约过期，通知后续等待者。

**3. 防止死锁**
- 合理设置 TTL：确保任务能在 TTL 内完成，否则锁自动释放。
- 续约失败处理：监控 `keepAliveCh` 的关闭，及时终止任务。


#### redlock 锁
多个单节点 redis 共同实现分布式锁，set一半以上成功，可以视为加锁成功

基于 redis 的 redlock 存在时钟跳跃问题，需要实现全局时钟


#### zookeeper 锁

watch 代价比较大，且仅支持一次值watch，之变化了需要重新watch

#### consul 锁

原生支持了分布式锁（提供了分布式锁的api），而 etcd 和 zookeeper 需要以来官方或者社区提供的包，如 etcd 官方提供的 concurrency 包



## # 总结
1. 从0~1实现高性能和高可靠秒杀活动的设计与开发工作，支持1万+qps，10万+在线参与秒杀活动
2. 多级缓存来构建库存查询接口的防御矩阵，使用 redis 和 etcd 分别实现高性能和高可靠的分布式锁
3. 使用 redis hash 来实现剩余库存的查询、更新操作，业务层设计 WAL 模块，使用 mysql 来保存秒杀状态日志数据，使秒杀系统具备 crash safe 能力

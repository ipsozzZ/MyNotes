# go基础

---
## # 变量类型

### 整型
Go语言同时提供了有符号和无符号的整数类型，其中包括 int8、int16、int32 和 int64 四种大小截然不同的有符号整数类型，分别对应 8、16、32、64 bit（二进制位）大小的有符号整数，与此对应的是 uint8、uint16、uint32 和 uint64 四种无符号整数类型。此外还有两种整数类型 int 和 uint，它们分别对应特定 CPU 平台的字长（机器字大小），其中 int 表示有符号整数，应用最为广泛，uint 表示无符号整数。实际开发中由于编译器和计算机硬件的不同，int 和 uint 所能表示的整数大小会在 32bit 或 64bit 之间变化。通常int类型的处理速度也是最快的。

用来表示 Unicode 字符的 rune 类型和 int32 类型是等价的，通常用于表示一个 Unicode 码点。这两个名称可以互换使用。同样，byte 和 uint8 也是等价类型，byte 类型一般用于强调数值是一个原始的数据而不是一个小的整数。

最后，还有一种无符号的整数类型 uintptr，它没有指定具体的 bit 大小但是足以容纳指针。uintptr 类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。

尽管在某些特定的运行环境下 int、uint 和 uintptr 的大小可能相等，但是它们依然是不同的类型，比如 int 和 int32，虽然 int 类型的大小也可能是 32 bit，但是在需要把 int 类型当做 int32 类型使用的时候必须显示的对类型进行转换，反之亦然。

Go语言中有符号整数采用 2 的补码形式表示，也就是最高 bit 位用来表示符号位，一个 n-bit 的有符号数的取值范围是从 -2(n-1) 到 2(n-1)-1。无符号整数的所有 bit 位都用于表示非负数，取值范围是 0 到 2n-1。例如，int8 类型整数的取值范围是从 -128 到 127，而 uint8 类型整数的取值范围是从 0 到 255。


### 浮点型
Go语言提供了两种精度的浮点数 float32 和 float64，它们的算术规范由 IEEE754 浮点数国际标准定义，该浮点数规范被所有现代的 CPU 支持。这些浮点数类型的取值范围可以从很微小到很巨大。浮点数取值范围的极限值可以在 math 包中找到：
1. 常量 math.MaxFloat32 表示 float32 能取到的最大数值，大约是 3.4e38；
2. 常量 math.MaxFloat64 表示 float64 能取到的最大数值，大约是 1.8e308；
3. float32 和 float64 能表示的最小值分别为 1.4e-45 和 4.9e-324。

一个 float32 类型的浮点数可以提供大约 6 个十进制数的精度，而 float64 则可以提供约 15 个十进制数的精度，通常应该优先使用 float64 类型，因为 float32 类型的累计计算误差很容易扩散，并且 float32 能精确表示的正整数并不是很大。浮点数在声明的时候可以只写整数部分或者小数部分：如
```go
const e = .71828 // 0.71828
const f = 1.     // 1
```
很小或很大的数最好用科学计数法书写，通过 e 或 E 来指定指数部分；
注意**用Printf函数打印浮点数时可以使用“%f”来控制保留几位小数**


### 复数
在计算机中，复数是由两个浮点数表示的，其中一个表示实部（real），一个表示虚部（imag）。

Go语言中复数的类型有两种，分别是  complex128（64 位实数和虚数）和 complex64（32 位实数和虚数），其中 complex128 为复数的默认类型。复数的值由三部分组成 RE + IMi，其中 RE 是实数部分，IM 是虚数部分，RE 和 IM 均为 float 类型，而最后的 i 是虚数单位。如：
```go
var name complex128 = complex(x, y)
// 或 name := complex(x, y)
```
其中 name 为复数的变量名，complex128 为复数的类型，“=”后面的 complex 为Go语言的内置函数用于为复数赋值，x、y 分别表示构成该复数的两个 float64 类型的数值，x 为实部，y 为虚部。对于一个复数z := complex(x, y)，可以通过Go语言的内置函数real(z) 来获得该复数的实部，也就是 x；通过imag(z) 获得该复数的虚部，也就是 y。复数也可以用==和!=进行相等比较，只有两个复数的实部和虚部都相等的时候它们才是相等的。实际操作中建议使用复数默认的 complex128 类型，因为这些内置的包中都使用 complex128 类型作为参数。

### bool类型
Go语言对于值之间的比较有非常严格的限制，只有两个相同类型的值才可以进行比较，如果值的类型是接口（interface），那么它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值可以不是常量，但是类型必须和该常量类型相同。如果以上条件都不满足，则必须将其中一个值的类型转换为和另外一个值的类型相同之后才可以进行比较。注意**布尔值并不会隐式转换为数字值 0 或 1，反之亦然，Go语言中不允许将整型强制转换为布尔型，布尔型无法参与数值运算，也无法与其他类型进行转换。**

布尔值可以和 &&（AND）和 ||（OR）操作符结合，并且有短路行为，如果运算符左边的值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：```s != "" && s[0] == 'x'```其中 s[0] 操作如果应用于空字符串将会导致 panic 异常。


### go字符串
一个字符串是一个不可改变的字节序列，字符串可以包含任意的数据，但是通常是用来包含可读的文本，字符串是 UTF-8 字符的一个序列（当字符为 ASCII 码表上的字符时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。


UTF-8 是一种被广泛使用的编码格式，是文本文件的标准编码，其中包括 XML 和 JSON 在内也都使用该编码。由于该编码对占用字节长度的不定性，在Go语言中字符串也可能根据需要占用 1 至 4 个字节，这与其它编程语言如 C++、Java 或者 Python 不同（Java 始终使用 2 个字节）。Go语言这样做不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。


字符串是一种值类型，且值不可变，即创建某个文本后将无法再次修改这个文本的内容，更深入地讲，字符串是字节的定长数组。



可以使用双引号""来定义字符串，字符串中可以使用转义字符来实现换行、缩进等效果，常用的转义字符包括：
* \n：换行符
* \r：回车符
* \t：tab 键
* \u 或 \U：Unicode 字符
* \\：反斜杠自身

一般的比较运算符（==、!=、<、<=、>=、>）是通过在内存中按字节比较来实现字符串比较的，因此比较的结果是字符串自然编码的顺序。字符串所占的字节长度可以通过函数 len() 来获取，例如 len(str)。

**注意**：由于go的字符串的每个字符可能是一个字节或者多个字节表示的，字符串的内容（纯字节）可以通过标准索引法来获取，在方括号[ ]内写入索引，索引从 0 开始计数：第 i 个字节：str[i - 1]**需要注意的是，这种转换方案只对纯 ASCII 码的字符串有效。获取字符串中某个字节的地址属于非法行为，例如 &str[i]。**

字符串拼接
1. 字符串拼接符“+”
两个字符串 s1 和 s2 可以通过 s := s1 + s2 拼接在一起。将 s2 追加到 s1 尾部并生成一个新的字符串 s。

可以通过下面的方式来对代码中多行的字符串进行拼接：
```go
str := "Beginning of the string " +
"second part of the string"
```
**提示：因为编译器会在行尾自动补全分号，所以拼接字符串用的加号“+”必须放在第一行末尾。**

2. 也可以使用“+=”来对字符串进行拼接

3. 定义多行字符串：
在Go语言中，使用双引号书写字符串的方式是字符串常见表达方式之一，被称为字符串字面量（string literal），这种双引号字面量不能跨行，如果想要在源码中嵌入一个多行字符串时，就必须使用`反引号，代码如下：
```go
const str = `第一行
第二行
第三行
\r\n
`
fmt.Println(str)

// 代码运行结果：
/*
第一行
第二行
第三行
\r\n
*/

```

**注意：在这种方式下，反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。** 多行字符串一般用于内嵌源码和内嵌数据等


### 字符类型
Go语言的字符有以下两种：
1. 一种是 uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符。byte 类型是 uint8 的别名，对于只占用 1 个字节的传统 ASCII 编码的字符来说，完全没有问题，例如 var ch byte = 'A'，字符使用单引号括起来。
2. 另一种是 rune 类型，代表一个 UTF-8 字符，当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。rune 类型等价于 int32 类型。

```go
var ch byte = 65 或 var ch byte = '\x41'      //（\x 总是紧跟着长度为 2 的 16 进制数）
```
另外一种可能的写法是\后面紧跟着长度为 3 的八进制数，例如 \377。Go语言同样支持 Unicode（UTF-8），因此字符同样称为 Unicode 代码点或者 runes，并在内存中使用 int 来表示。在文档中，一般使用格式 U+hhhh 来表示，其中 h 表示一个 16 进制数。

在书写 Unicode 字符时，需要在 16 进制数之前加上前缀\u或者\U。因为 Unicode 至少占用 2 个字节，所以我们使用 int16 或者 int 类型来表示。如果需要使用到 4 字节，则使用\u前缀，如果需要使用到 8 个字节，则使用\U前缀。
```go
var ch int = '\u0041'
var ch2 int = '\u03B2'
var ch3 int = '\U00101234'
fmt.Printf("%d - %d - %d\n", ch, ch2, ch3) // integer
fmt.Printf("%c - %c - %c\n", ch, ch2, ch3) // character
fmt.Printf("%X - %X - %X\n", ch, ch2, ch3) // UTF-8 bytes
fmt.Printf("%U - %U - %U", ch, ch2, ch3)   // UTF-8 code point
// 输出：
// 65 - 946 - 1053236
// A - β - r
// 41 - 3B2 - 101234
// U+0041 - U+03B2 - U+101234
```

Unicode 包中内置了一些用于测试字符的函数，这些函数的返回值都是一个布尔值,如下所示（其中 ch 代表字符）：判断是否为字母：unicode.IsLetter(ch)，判断是否为数字：unicode.IsDigit(ch)，判断是否为空白符号：unicode.IsSpace(ch)

* UTF-8 和 Unicode 有何区别？
Unicode 与 ASCII 类似，都是一种字符集。字符集为每个字符分配一个唯一的 ID，我们使用到的所有字符在 Unicode 字符集中都有一个唯一的 ID，例如上面例子中的 a 在 Unicode 与 ASCII 中的编码都是 97。汉字“你”在 Unicode 中的编码为 20320，在不同国家的字符集中，字符所对应的 ID 也会不同。而无论任何情况下，Unicode 中的字符的 ID 都是不会变化的。UTF-8 是编码规则，将 Unicode 中字符的 ID 以某种方式进行编码，UTF-8 的是一种变长编码规则，从 1 到 4 个字节不等。编码规则如下：0xxxxxx 表示文字符号 0～127，兼容 ASCII 字符集。从 128 到 0x10ffff 表示其他字符。根据这个规则，拉丁文语系的字符编码一般情况下每个字符占用一个字节，而中文每个字符占用 3 个字节。广义的 Unicode 指的是一个标准，它定义了字符集及编码规则，即 Unicode 字符集和 UTF-8、UTF-16 编码等。


### 类型转换
类型 B 的值 = 类型 B(类型 A 的值)
1. 在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于Go语言不存在隐式类型转换，类型转换只能在定义正确的情况下转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型（将 int16 转换为 int32）。当从一个取值范围较大的类型转换到取值范围较小的类型时（将 int32 转换为 int16 或将 float32 转换为 int），会发生精度丢失（截断）的情况。
2. 只有相同底层类型的变量之间可以进行相互转换（如将 int16 类型转换成 int32 类型），不同底层类型的变量相互转换时会引发编译错误（如将 bool 类型转换为 int 类型）

### 指针
与 Java 和 .NET 等编程语言不同，Go语言为程序员提供了控制数据结构指针的能力，但是，并不能进行指针运算。Go语言允许你控制特定集合的数据结构、分配的数量以及内存访问模式，这对于构建运行良好的系统是非常重要的。指针对于性能的影响不言而喻，如果你想要做系统编程、操作系统或者网络应用，指针更是不可或缺的一部分。

指针（pointer）在Go语言中可以被拆分为两个核心概念：
* 类型指针，允许对这个指针类型的数据进行修改，传递数据可以直接使用指针，而无须拷贝数据，类型指针不能进行偏移和运算。
* 切片，由指向起始元素的原始指针、元素数量和容量组成。

创建指针的另一种方法——new() 函数, Go语言还提供了另外一种方法来创建指针变量，格式如下：new(类型)

一般这样写：
```go
str := new(string)
*str = "Go语言笔记"
fmt.Println(*str)
```
new() 函数可以创建一个对应类型的指针，创建过程会分配内存，被创建的指针指向默认值。


### 变量逃逸案例

在程序的编译阶段，编译器会根据实际情况自动选择在栈或者堆上分配局部变量的存储空间，不论使用 var 还是 new 关键字声明变量都不会影响编译器的选择。

```go
var global *int
func f() {
    var x int
    x = 1
    global = &x
}
func g() {
    y := new(int)
    *y = 1
}
```
上述代码中，函数 f 里的变量 x 必须在堆上分配，因为它在函数退出后依然可以通过包一级的 global 变量找到，虽然它是在函数内部定义的。用Go语言的术语说，这个局部变量 x 从函数 f 中逃逸了。相反，当函数 g 返回时，变量 *y 不再被使用，也就是说可以马上被回收的。因此，*y 并没有从函数 g 中逃逸，编译器可以选择在栈上分配 *y 的存储空间，也可以选择在堆上分配，然后由Go语言的 GC（垃圾回收机制）回收这个变量的内存空间。在实际的开发中，并不需要刻意的实现变量的逃逸行为，因为逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。虽然Go语言能够帮助我们完成对内存的分配和释放，但是为了能够开发出高性能的应用我们任然需要了解变量的声明周期。例如，如果将局部变量赋值给全局变量，将会阻止 GC 对这个局部变量的回收，导致不必要的内存占用，从而影响程序的性能。


### 常量
Go语言中的常量使用关键字 const 定义，用于存储不会改变的数据，常量是在编译时被创建的，即使定义在函数内部也是如此，并且只能是布尔型、数字型（整数型、浮点型和复数）和字符串型。由于编译时的限制，定义常量的表达式必须为能被编译器求值的常量表达式。在Go语言中，你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。和变量声明一样，可以批量声明多个常量。
* 显式类型定义： const b string = "abc"
* 隐式类型定义： const b = "abc"

常量的值必须是能够在编译时就能够确定的，可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。
* 正确的做法：const c1 = 2/3
* 错误的做法：const c2 = getNumber() // 引发构建错误: getNumber() 用做值

1. 常量声明可以使用 iota 常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 const 声明语句中，在第一个声明的常量所在的行，iota 将会被置为 0，然后在每一个有常量声明的行加一。

2. 无类型常量，Go语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如 int 或 float64，或者是类似 time.Duration 这样的基础类型，但是许多常量并没有一个明确的基础类型。编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有 256bit 的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。通过延迟明确常量的具体类型，不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。

3. 使用ioda定义常量：
格式： "const [常量名] ioda" 或者 "var(a = ioda; b = ioda; ...)" 或者 "var(a = ioda; b ; c; d; ...)" 或者 "var(a = ioda; b,c,d = ioda, ioda, ioda; ...)注意这里逗号隔开的值是相同的"
需要注意的点：ioda的赋值是从0开始每个语句加1；ioda遇到下一个const后置0；同一个语句里逗号隔开的值相同；ioda赋值可以简写，具体见格式


### 类型别名
定义类型别名的写法为：type TypeAlias = Type

类型别名规定：TypeAlias 只是 Type 的别名，本质上 TypeAlias 与 Type 是同一个类型，就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。

1. 非本地类型不能定义方法（取别名的类型不能用来声明方法）
2. 在结构体成员嵌入时不能使用别名

---
## # 集合

### 数组
数组的声明语法如下：var 数组变量名 [元素数量]Type   
语法说明如下所示：
数组变量名：数组声明及使用时的变量名。
元素数量：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整型数值，元素数量不能含有到运行时才能确认大小的数值。
Type：可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组。

声明多维数组的语法如下所示：
var array_name [size1][size2]...[sizen] array_type


### 切片
切片（slice）是对数组的一个连续片段的引用，所以切片是一个引用类型，这个片段可以是整个数组，也可以是由起始和终止索引标识的一些项的子集，需要注意的是，终止索引标识的项不包括在切片内。Go语言中切片的内部结构包含地址、大小和容量，切片一般用于快速地操作一块数据集合，如果将数据集合比作切糕的话，切片就是你要的“那一块”，切的过程包含从哪里开始（切片的起始位置）及切多大（切片的大小），容量可以理解为装切片的口袋大小，如下图所示。

语法：
从连续内存区域生成切片是常见的操作，格式如下：
slice [开始位置 : 结束位置]  
语法说明如下：
slice：表示目标切片对象；
开始位置：对应目标切片对象的索引；
结束位置：对应目标切片的结束索引。

如：```var a  = [3]int{1, 2, 3}; a[1:2]``` 
其中 a 是一个拥有 3 个整型元素的数组，被初始化为数值 1 到 3，使用 a[1:2] 可以生成一个新的切片

从数组或切片生成新的切片拥有如下特性：
* 取出的元素数量为：结束位置 - 开始位置；
* 取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取；
* 当缺省开始位置时，表示从连续区域开头到结束位置；
* 当缺省结束位置时，表示从开始位置到整个连续区域末尾；
* 两者同时缺省时，与切片本身等效；
* 两者同时为 0 时，等效于空切片，一般用于切片复位。

注意几点：
1. 当slice [:]时生成的切片是原本切片或数组的所有值  
2. 把切片的开始和结束位置都设为 0 时，生成的切片将变空，如：slice [0:0]将得到：[]
3. 除了可以从原有的数组或者切片中生成切片外，也可以声明一个新的切片，每一种类型都可以拥有其切片类型，表示多个相同类型元素的连续集合，因此切片类型也可以被声明，切片类型声明格式如下：```var name []Type```
4. 使用 make() 函数构造切片:make( []Type, size, cap ):如：a := make([]int, 2)
5. Go语言的内建函数 append() 可以为切片动态添加元素
6. Go语言的内置函数 copy() 可以将一个数组切片复制到另一个数组切片中，如果加入的两个数组切片不一样大，就会按照其中较小的那个数组切片的元素个数进行复制。

### Go语言nil
在Go语言中，布尔类型的零值（初始值）为 false，数值类型的零值为 0，字符串类型的零值为空字符串""，而指针、切片、映射、通道、函数和接口的零值则是 nil。nil 是Go语言中一个预定义好的标识符，有过其他编程语言开发经验的开发者也许会把 nil 看作其他语言中的 null（NULL），其实这并不是完全正确的，因为Go语言中的 nil 和其他语言中的 null 有很多不同点。

1. nil 标识符是不能比较的
2. nil 不是关键字或保留字
3. nil 没有默认类型
4. 不同类型 nil 的指针是一样的
5. 不同类型的 nil 是不能比较的
6. 两个相同类型的 nil 值也可能无法比较
7. nil 是 map、slice、pointer、channel、func、interface 的零值
8. 不同类型的 nil 值占用的内存大小可能是不一样的

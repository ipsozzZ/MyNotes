# JVM内存管理

## # 内存模型

1. 线程私有内存（通常固定大小）
- 程序计数器(每个线程都有的，PC存储当前正在执行的方法(非native方法)，占用很小的内存，唯一不会引发内存异常的内存)
- Java虚拟机栈：方法的栈帧（通过-Xss设置大小）
- 本地方法栈(存储native方法的内存，线程私有（通常固定大小）)

2. 多线程共享内存
- 堆（-Xms设置初始堆大小，Xmx设置最大堆内存）：当在程序中申请一个数组、或者new一个对象时，其内存就会分配在堆上，当声明一个int、byte的变量时内存分配是在线程的栈内存上分配的。
- 方法区（-XX设置大小, 如：-XX:MaxMetaspaceSize=9M）：存储JVM已经加载类的结构，JVM启动时创建，逻辑上属于堆内存，所有线程共享，运行时常量池、类信息、常量、静态变量等也存在于方法区中
-- 运行时常量池：Class文件中常量池的运行时表示。动态性，Java语言并不要求常量一定只有在编译时产生，比如String.intern方法

3. windows10 jvm堆内存参数查看命令：java -XX:+PrintFlagsFinal -version | findstr HeapSize

## # 垃圾回收之对象引用

1. Java程序提供的Object类中的finalze方法，不靠谱，也是需要靠JVM判定回收时间

2. Java程序提供的System.gc方法，官方都不建议调用，也是需要靠JVM判定回收时间

3. 对象引用：线程栈中存在堆内存中对象的指针就是对象的引用。
- 垃圾回收原理判断无用的对象是基于对象的引用，无用对象：零引用、互相引用等

- 对象引用链：通过一系列的称为"GC Roots"的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（就是从GC Roots到这个对象不可达）时，证明这对象是不可用的

- GC Roots对象包括(即活着的对象)：
-- 虚拟机中引用的对象
-- 方法区中静态属性引用的对象
-- 方法区中常量引用的对象
-- 本地方法栈中引用的对象

4. 对象引用类型

- 强引用：我们常用的引用都是强引用，比如Object A = new Object();

- 软引用：描述有用但并非必须的对象，在系统将要发生溢出前将其标注为可回收引用，JDK提供SoftReference类来实现软引用

- 弱引用：描述有用但并非必须的对象，只能生存到下一次垃圾回收之前，JDK提供WeakReference类来实现弱引用

- 虚引用：最弱的引用关系，不会对对象生存周期造成影响，随时随地都会被回收掉的，JDK提供PhantomReference类来实现虚引用，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知，用于对象回收跟踪。

- 除了强引用以为其它引用的作用：
软引用，我们可以用来保存一些可有可无的缓存数据，内存紧张的时候它会自动被回收掉，从而将内存使用在更重要的地方，内存不紧张的时候用来缓存数据；弱引用，用来确保一个引用在调用了System.gc方法后就会被回收掉；虚引用正常业务基本不用考虑，它是用来跟踪对象回收的。

## # 垃圾回收之垃圾回收算法

1. 引用计数器
- 一种古老的算法
- 每一个对象都有一个引用计数器
- 有引用计数器加一，当引用失效计数器减一
- 计算器为0的对象将被回收
- 优点：效率高、简单
- 缺点：无法识别对象之间相互循环引用

2. 标记-清楚
- 标记阶段：标出所有需要回收的对象(根据引用计数法来判断是否需要回收)
- 回收阶段：统一回收所有被标记的对象
- 优点：简单
- 缺点：效率不高、内存碎片

3. 复制算法
- 将可用内存按容量划分为大小相等的两块，每次只使用其中一块。
- 当这一块的内存使用完了，就将还在活着的对象复制到另一快内存上面
- 然后把已使用过的内存空间一次清理掉
- 优点：简单、高效
- 缺点：可用内存较小、存活对象较多时复制操作较多

4. 标记-整理
- 标记阶段：与标记清除算法一样
- 整理阶段：让所有存活的对象都一端移动，然后直接清除掉端边界以为的内存
- 优点：避免碎片产生、无需两块相同的内存
- 缺点：计算代价大，标记清除+碎片整理、更新引用地址

5. 分代收集
- Java对象的生命周期不同，有长有短
- 根据对象存活周期，将对象划分为新生代和老年代
- 新生代：复制算法；分为Eden(80%)和两块survivor space(20%)，新创建的对象都会被放到Eden区和surviver中的一个区中，经过一次gc还或者的放到survivor的另一个区中，然后清空Eden和被使用过的survivor区，再下一次gc又把Eden和正在使用的survivor区存活的对象放到未使用的survivor区，循环几次后依然存活的对象放到老年代
-- 主要存放短生命周期的对象
-- 新创建的对象都先放入新生代，大部分新创建的对象在第一次GC时被回收
- 老年代：标记清除或标记整理算法
-- 对象经过几次gc仍然存活，则放入老年代
-- 这些对象可以活很长的时间，或者相伴程序一生，需要常驻内存的，可以减少回收次数。


## # 垃圾回收之垃圾回收参数

1. 堆内存参数：
- -Xms初始堆大小
- -Xmx最大堆大小
- Xmn新生代大小
- -XX:SurvivorRatio设置eden区/From(to)的比例
- -XX:NewRatio设置老年代/新生代比例
- -XX:+PrintGC/-XX:+PrintGCDetails打印GC的过程信息
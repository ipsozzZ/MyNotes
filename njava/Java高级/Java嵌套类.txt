嵌套类：
- 静态嵌套类，即类前面有static修饰符
- 非静态嵌套类，又叫内部类(注意static修饰的嵌套类不是内部类)，包括：普通内部类、局部内部类、匿名内部类。
- 为什么需要嵌套类：不同的访问权限要求，更细粒度的访问控制；简洁避免过多的类定义；缺点是语言设计过于复杂，较难学习和使用。

1. 静态嵌套类
- 层级和类成员一样
- 第三方类需要通过上层类才可以访问到静态类
- 第三方类调用时创建实例的方法：A.B b = new A.B();
- 在内部可以定义静态成员和普通成员
- 只可以访问上层类的静态成员
- new出来的对象也不是唯一的，尽管
例：
public class A{
    String nameA;

    static class B{
        String nameB;
    }
}

2. 普通内部类（也叫成员内部类）
- 可以被其它第三方类调用（调用的方法：A a = new A();   A.B b = a.new B();）,普通内部类对象依赖于上层类的对象，不能单独存在
- 编译后class文件名字：上层类名+$+内部类名
- 可以实现其他类或者其他接口
- 可以用控制访问修饰符修饰来控制其他外部类访问，如private、public等
例：
public class A{
    String nameA;
    // 普通内部类
    public class B{
        String nameB;
    }
}

3. 局部内部类(不能是接口)
- 编译后class文件名字：上层类名+$+序号+内部类名
- 有构造函数，可以继承类或者实现接口
- 定义在代码块中的内部类
- 定义后，即可创建对象使用
- 只能活在这个代码块中，代码块结束后，外界无法使用该类
- 不允许定义静态成员，但是允许定义常量
- 可以访问外围类的普通成员变量(外围类名.this.变量名；包括私有方法)
- 如果局部内部类去调用统一代码块的局部变量，则该局部变量必须是final否则无法调用
例：
public class A{
    String nameA;

    public void f1{
        // 局部内部类
        public class B{
              String nameB;
        }
    }
}

4. 匿名内部类
- 没有类名（编译器内部编译后产生名字：上层类名+$+数字编号）
- 没有构造函数，能用父类的构造函数
- 必须继承一个父类/实现一个父接口
- 在实例化后迅速转型为父类/父接口
- 这种类型的对象，只能new一个，之后以对象名字(注意不是类名字，匿名类没有名字)操作
- 可以在普通语句和成员变量赋值时使用内部类
- 注意静态方法、静态变量不能在静态内部类中定义，常量除外
- 外部类和上层类无法访问内部类
- 内部类可以访问上层类的私有方法
例：
public class A{
    String nameA;

    public void f1{
        // 匿名内部类
        new Thread(new Runnable(){
              public void run(){
                  System.out.println(A.this.nameA)// 访问上层类的成员变量(注意如果f1方法是静态方法则只能访问上层类的静态成员)
              }
        }).start();
    }
}

5. 嵌套的应用
- 匿名内部类：使用一次，在安卓开发中比较常见

- 局部内部类：只用一次，只在某代码块中使用，一个运用场景是继承某个类或某个接口，重装其方法，并当作返回值在外部使用，Java中Pattern类中splitAsStream方法有应用。

- 普通内部类：广泛使用在具有母子结构的类，内部类对象和外围类保持联系，如Map和Map.Entry、ZipFile和ZipFile.ZipEntryIterator等。

- 静态嵌套类：和普通类一致，只是"碰巧"声明在一个类的内部，和上层类没有太多联系，其对象可以脱离上层类对象存在(如果一个普通内部类和其上层类的成员变量没有联系的话优先选择使用静态内部类，这样就可以减少普通内部类和其上层类的联系开销，再者可以是的上层对象更容易被垃圾回收器回收)



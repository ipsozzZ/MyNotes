# 极客时间-数据结构与算法

** 内存泄漏是指程序在申请内存后，无法释放已申请的内存空间。内存溢出是指程序申请内存时，没有足够的内存供申请者使用；或者说提供一块存储int数据的存储空间，但存储了long数据，则结果是内存不够用，报错OOM。内存泄漏的堆积最终会导致内存溢出。**

内存溢出（Out Of Memory） ：就是申请内存时，JVM没有足够的内存空间。通俗说法就是去蹲坑发现坑位满了。
内存泄露 （Memory Leak）：就是申请了内存，但是没有释放，导致内存空间浪费。通俗说法就是有人占着茅坑不拉屎。

## # 入门篇

#### 时间复杂度
所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比。
T(n) = O(f(n))
其中，T(n) 它表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

* 定义：** 大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。**
* 常见复杂度： O(1)、O(logn)、O(n)、O(nlogn)、O(n^2 )
* 时间复杂度类别：最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度、均摊时间复杂度
* 对数相关： 若：2^0  2^1  2^2  ...  2^k  ...  2^x = n, 则: x=log2n(读作log以2为底n的对数);
* 对数运算: log3n = log32 * log2n=

#### 空间复杂度

* 空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系
* 常见复杂度: O(1)、O(n)、O(n^2 )


## # 基础篇

#### 数组
数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

* -注意点：
    1. 切忌将数组的查找时间复杂度认为是O(1)，无序数组的查找时间复杂度应该是O(n)，有序的二分查找的时间复杂度是O(logn),，正确的描述应该是数组随机访问下标对应元素的时间复杂度是O(1)


* -使用技巧：
假设数组arr有100W个元素，数组长度是110W，现在需要删除arr[5]、arr[6]、arr[7]，如果接到删除命令就开始删除数据，数组为了保证地址连续性，没删除一个数组元素则会移动数组进百万次，如果当前系统处于繁忙时段，再执行这个删除逻辑的话将会使计算机资源使用更紧张甚至进程崩溃宕机；如果删除时，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。

* -数组为啥下标从0开始，而不是从1开始？（可能的原因之一）
从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式：a[k]_address = base_address + k * type_size
但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：a[k]_address = base_address + (k-1)*type_size对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。


#### 链表上

空间换时间与时间换空间：对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。



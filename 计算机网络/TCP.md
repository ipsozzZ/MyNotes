## # TCP（传输控制协议）
TCP（传输控制协议）是互联网中最重要的传输层协议之一，负责在不可靠的网络上提供**可靠的、面向连接**的数据传输。以下是 TCP 协议的核心详解：

---

### 一、核心特点
1. **可靠性**  
   - 数据分段、确认重传（ACK）、超时重传、校验和（Checksum）确保数据完整到达。
2. **面向连接**  
   - 通信前需通过**三次握手**建立连接，结束后通过**四次挥手**释放连接。
3. **全双工通信**  
   - 双方可同时发送和接收数据。
4. **流量控制**  
   - 通过滑动窗口（Sliding Window）机制动态调整发送速率，防止接收方溢出。
5. **拥塞控制**  
   - 通过慢启动、拥塞避免、快速重传、快速恢复等算法避免网络拥塞。

---

### 二、TCP 报文结构
TCP 报文头部固定为 **20 字节**（可扩展选项字段）：
```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         源端口号（16位）       |       目的端口号（16位）       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       序列号（32位）                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     确认号（32位）                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| 数据偏移 | 保留 | 控制标志（URG/ACK/PSH/RST/SYN/FIN） | 窗口大小  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+v
|        校验和（16位）         |        紧急指针（16位）        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           选项（可选）                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
- **关键字段**：
  - **序列号（Sequence Number）**：标识数据段的顺序。
  - **确认号（Acknowledgment Number）**：期望接收的下一个数据段的序列号。
  - **控制标志**：
    - **SYN**：发起连接（同步序列号）。
    - **ACK**：确认数据有效。
    - **FIN**：终止连接。
    - **RST**：重置异常连接。
    - **URG**：紧急数据（需配合紧急指针使用）。
    - **PSH**：提示接收端立即处理数据。

---

### 三、TCP 连接管理
#### 1. 三次握手（建立连接）
```
客户端 -> SYN=1, Seq=x            -> 服务端
客户端 <- SYN=1, ACK=1, Seq=y, Ack=x+1 <- 服务端
客户端 -> ACK=1, Ack=y+1         -> 服务端
```
- **目的**：协商初始序列号（ISN），确认双方收发能力正常。

#### 2. 四次挥手（释放连接）
```
客户端 -> FIN=1, Seq=u           -> 服务端
客户端 <- ACK=1, Ack=u+1         <- 服务端
客户端 <- FIN=1, Seq=v, ACK=1    <- 服务端
客户端 -> ACK=1, Ack=v+1         -> 服务端
```
- **TIME_WAIT 状态**：客户端等待 2MSL（最大报文生存时间），确保最后一个 ACK 到达服务端。

---

### 四、可靠性机制
1. **确认与重传**  
   - 接收方通过 ACK 确认数据，发送方超时未收到 ACK 则重传。
2. **有序传输**  
   - 通过序列号重组乱序到达的数据。
3. **流量控制**  
   - 接收方通过窗口大小字段告知发送方可接收的数据量。
4. **拥塞控制**  
   - **慢启动**：初始窗口小，指数级增长。
   - **拥塞避免**：窗口线性增长。
   - **快速重传**：收到 3 个重复 ACK 立即重传。
   - **快速恢复**：避免窗口骤降。

---

### 五、常见问题
1. **为什么握手是三次，挥手是四次？**  
   - 建立连接时，服务端可将 SYN 和 ACK 合并发送；但关闭连接时，服务端可能仍有数据需发送，需先回复 ACK，再发送 FIN。
2. **TIME_WAIT 的作用？**  
   - 防止旧连接的延迟报文干扰新连接，并确保对方收到最终 ACK。
3. **TCP 粘包/拆包问题**  
   - 需应用层协议定义边界（如固定长度、分隔符、头部声明长度）。

---

### 六、应用场景
- **适用场景**：需可靠传输（如 HTTP、FTP、邮件）。
- **不适用场景**：实时性要求高（如视频流、游戏），此时可用 UDP。

---

### 七、常见端口号
- HTTP: 80
- HTTPS: 443
- FTP: 21（控制）、20（数据）
- SSH: 22

---

通过理解 TCP 的机制，可以更好地优化网络应用，排查连接超时、丢包等问题。



## # io模型

#### select

缺点：
1. 单个进程所打开的FD是有限制的，通过 FD_SETSIZE 设置，默认1024

2. 每次调用 select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大

3. 每次调用select都需要将进程加入到所有监视socket的等待队列，每次唤醒都需要从每个队列中移除

4. select函数在每次调用之前都要对参数进行重新设定，这样做比较麻烦，而且会降低性能

5. 进程被唤醒后，程序并不知道哪些socket收到数据，还需要遍历一次

#### poll
poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的。

#### epoll
epoll可以理解为event pool，不同与select、poll的轮询机制，epoll采用的是事件驱动机制，每个fd上注册有回调函数，当网卡接收到数据时会回调该函数，同时将该fd的引用放入rdlist就绪列表中。当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。

**log.Fatal这个函数只建议在init和main函数中使用，其它任务地方都不要使用**

## # 必会算法题

1. 快慢指针
2. 滑动窗口
3. 动态规划

#### 链表 (力扣: 206，141，21，19，876)
1. 单链表反转
2. 链表中环的检测
3. 两个有序的链表合并
4. 删除链表倒数第 n 个结点
5. 求链表的中间结点

#### 树
1. 树的类型
2. 红黑树
3. b树
4. 字典树
5. 二叉树常见种类，求度、求树高
6. 二叉树中序、前序、层次遍历
7. 深度优先和广度优先搜索
8. 跳表

#### 数组
1. 排序算法


## # 架构

slb（layer 7 代理）

istio (服务网格)

api Gateway  （srs，即service router socket, 主要是玩家鉴权、外部流量分发、流量染色）

cyane （微服务内部流量分发、防腐）

Backend for Frontend    (poseidon、hadis)

内部微服务


#### 从单体到微服务的问题-单体
1. 单体数据常驻内存
5. 运维问题

#### 从单体到微服务的问题-微服务
1. 跨进程服务调用，存在网络问题
2. 多数据库维护
3. 需要多服务维持可测环境提供测试人员
4. 业务数据不能常驻内存(无状态)


#### 服务网格istio
性能和功能都优于传统的微服务架构: spring cloud 和 dubbo ，这两者业务开发者可能需要处理服务注册、服务发现、负载均衡等。而istio则将这些运维需求抽离业务，使微服务专注于业务处理，降低了微服务的使用门槛。
1. 控制层
    * 不直接解析数据包
    * 与控制平面中的代理通信，下发策略和配置
    * 负责网络行为的可视化
    * 通常提供API或者命令行工具可用于配置版本化管理，便于持续集成和部署

2. 数据层（envoy实现）
    * 通常是按照无状态目标设计的，但实际上为了提高流量转发性能，需要缓存一些数据，因此无状态也是有争议的
    * 直接处理入站和出站数据包，转发、路由、健康检查、负载均衡、认证、鉴权、产生监控数据等
    * 对应用来说透明，即可以做到无感知部署



#### gRPC (项目中的使用)
1. grpc
    * grpc有一个标准的健康检测协议
    * 

2. 项目使用情况
    * 协议即文档
    * 统一的错误码，（根据不同服务使用不同的错误码分段，可以方便后期根据错误码做服务监控）


## # 服务发现

#### 客户端发现
将服务注册中的所有服务信息加载到自己本地，使用本地自己的负载均衡策略
缺点：需要服务自己做负载均衡，服务信息更新等

#### 服务端发现
依赖同一的服务信息，进行统一策略的负载均衡
缺点：容易产生热点数据

#### 项目中的应用
微服务是容器化的，所以将服务发现等使用与业务独立的pod运行，即客户端发现方式加了一层代理与业务代码进行隔离。

#### eruka服务注册中心



#### 开启一个新goroutine的原则
1. 如果把一件交给新goroutine执行的任务，需要当前goroutine等待完成后再往后执行，那就不该创造这个新的goroutine来执行这个任务，应该由当前这个goroutine自己执行这个任务；
2. 让调用者来决定要不要并行,如果非要启动新的goroutine,需要将关闭方法交给调用者
3. goroutine什么时候结束，有无结束goroutine的手段。

## # goroutine 泄露的例子

1. 例子1
```go

func ListDir(dir string) ch chin {
    // ...
}

```
调用者 通过从ch中一条一条读取来获得数据；当读到默认值时认为读取完毕
存在的问题：从ch中读取到默认值不一定是读取完毕，还可能是错误导致的关闭，由于没有error信息，所以读取者无法区分错误还是读取完毕


2. func ListDir() ch chin 
问题(goroutine设计上的缺陷)：调用者无法确定ListDir函数内部是否开启新的goroutine读取数据，如果调用者已经取到想要的数据，不会再从ch读取数据，导致ch的buf满了，阻塞了ListDir中的goroutine，从而导致goroutine泄露。
解决：func ListDir(dir string, fn func(string)) ch chin

3. 有读取，没有写入，导致读取goroutine阻塞泄露
```go

func leak() {
	ch := make(chan int32)

	go func() {
		val := <-ch
		fmt.Println("I received a value:", val)
	}()
}

```
没有goroutine往ch中写入数据，导致新启的goroutine一直阻塞，导致泄露


4. 有写无读导致写入goroutine阻塞泄露

```go

func ss() {

    // ...
    go func() {
        record, err := search(term)
        ch <- result{record, err}
    }()

    // ...

    select {
        case <-ctx.Done():
            return errors.New("search canceled")
        case result := <-ch:
            if result.err != nil {
                return result.err
            }
            fmt.Println("Received: ", result.record)
            return nil
    }

}

```
问题：当select 先接收到<-ctx.Done()时，没有goroutine读取ch导致ch所在goroutine阻塞泄露
解决：将ch的buf设置为1，不要使用阻塞式


## # 项目介绍

#### 折扣服务
1. 提供折扣、限免等优惠能力
2. 不针对业务提供服务，比如不针对房费提供服务
3. 提供定制能力（产品配置-业务通过约定的配置参数进行）

#### 包厢服务
1. 服务能力拆分
2. 数据库优化
3. 配置优化

#### 保皇服务
1. erlang grpc接入
2. golang 保皇玩法设计（踢掉状态机）
3. 容器化运行


#### 项目遇到的问题-服务重构

1. 服务拆分；（业务拆分）
2. 客户端不做支持的情况下，保证服务稳定、以及代码防腐；（后期申请了一个客户端进行协助，增加防腐层，净化微服务集群的接口定义）
3. 新老架构兼容；（在内部网关分发流量是进行判断，将未迁移至新架构的流量标记，外部网关做meta标识校验，将该流浪转移至对应架构的服务进行处理）
4. 测试环境，创建过测试环境1、测试环境2、测试环境3等，但还是经常互相影响；（后期对测试集群和正式集群进行了多租户流浪转发，解决测试环境的问题）
5. 超时控制、过载保护、限流（无脑限流）、降级、重试、负载均衡

#### 项目遇到的问题-业务逻辑升级
1. 语言问题(erlang - go)；
2. 无状态化（内存读取到redis读取的延时问题）
3. 踢出状态机（状态管理问题）
4. erlang grpc库问题
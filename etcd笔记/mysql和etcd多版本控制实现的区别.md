# MySQL MVCC 和 etcd MVCC 的区别

MySQL 的 MVCC（多版本并发控制）和 etcd 的 MVCC 在核心思想（维护数据多版本以实现并发控制）上有相似之处，但它们在设计目标、实现机制和应用场景上存在显著差异。以下是两者的主要区别：

---

## # 1. 设计目标
- MySQL MVCC：
  - 事务隔离：主要为了解决数据库事务的并发冲突（如脏读、不可重复读、幻读），实现不同隔离级别（如 `READ COMMITTED`、`REPEATABLE READ`）。
  - 读写并发优化：通过版本快照避免读操作阻塞写操作（或反之），提升高并发场景下的性能。

- etcd MVCC：
  - 分布式一致性：作为分布式键值存储，MVCC 用于支持分布式系统下的线性一致性（Linearizable）读写，保证多节点间的数据一致性。
  - 历史版本追踪：天然支持对键值对的历史版本查询和监听（watch），便于实现配置管理、服务发现等场景的版本回溯。

---

## # 2. 实现机制
- MySQL MVCC：
  - 版本链与 Undo Log：
    - 每个数据行包含隐藏字段（如 `DB_TRX_ID` 表示最后修改的事务ID，`DB_ROLL_PTR` 指向 Undo Log 中的旧版本）。
    - 事务通过 `ReadView` 判断可见性：根据事务启动时间和活跃事务列表，决定哪些版本对当前事务可见。
  - 隔离级别依赖：
    - 在 `REPEATABLE READ` 级别下，事务首次读取时会建立一致性视图，后续读取沿用该视图。
    - 通过 `Undo Log` 清理旧版本（受 `undo_retention` 参数控制）。
  - 锁机制配合：
    - 写操作（如 `UPDATE`）会加行锁或间隙锁（Gap Lock），防止幻读。

- etcd MVCC：
  - 全局单调递增版本号：
    - 每次修改（如 `Put`、`Delete`）生成一个全局递增的 `revision`，所有键的修改共享同一版本序列。
    - 每个键的值以版本号为后缀存储（例如 `/key/123` 表示 `revision=123` 的版本）。
  - 内存与磁盘分离：
    - 最新数据存储在内存（B-tree 索引），旧版本存储在磁盘（BoltDB）。
    - 通过定期压缩（`Compact`）清理旧版本，释放空间。
  - 无锁读操作：
    - 读操作直接基于指定 `revision` 的快照，无需加锁，天然支持线性一致性读。

---

## # 3. 并发控制策略
- MySQL MVCC：
  - 悲观锁主导：写操作默认加锁（如行锁、间隙锁），可能导致锁竞争。
  - 事务冲突检测：通过版本可见性判断和锁机制解决冲突（如 `UPDATE` 时检查当前版本是否可见）。

- etcd MVCC：
  - 乐观并发控制：
    - 通过携带版本号（如 `ModRevision`）的原子操作（如 `CompareAndSwap`）实现乐观锁。
    - 无写写冲突：同一键的并发写入由 Raft 共识算法保证顺序，最终只有一个写入成功。
  - 无锁快照读：读操作基于历史版本快照，无需锁机制。

---

## # 4. 数据存储模型
- MySQL MVCC：
  - 行存储：面向关系型数据模型，MVCC 以行为单位维护版本。
  - 物理多版本：通过 Undo Log 存储旧版本数据，物理上不同版本可能分散在多个日志中。

- etcd MVCC：
  - 键值存储：简单的键值模型，每个键的多个版本独立存储。
  - 逻辑多版本：所有键的修改共享全局 `revision`，版本号是逻辑递增的。

---

## # 5. 应用场景
- MySQL MVCC：
  - 适合传统 OLTP 场景，如银行交易、订单处理，需要复杂事务和强一致性。
  - 例如：事务 A 读取数据的同时，事务 B 可以修改数据，但事务 A 的读操作不受影响。

- etcd MVCC：
  - 适合分布式系统协调、配置管理、服务发现等场景。
  - 例如：监听某个键的变更（`watch`），或查询某个键在历史时间点的值。

---

## # 总结对比表
| 特性               | MySQL MVCC                     | etcd MVCC                     |
|------------------------|------------------------------------|------------------------------------|
| 核心目标           | 事务隔离与读写并发优化             | 分布式一致性与历史版本管理         |
| 版本号机制         | 事务ID（隐式）                     | 全局递增 `revision`（显式）       |
| 锁机制             | 悲观锁（行锁、间隙锁）             | 无锁读 + 乐观锁（CAS）            |
| 存储模型           | 行存储 + Undo Log                 | 键值存储 + 全局版本序列            |
| 历史数据清理       | 通过 Undo Log 回收                | 定期压缩（`Compact`）             |
| 典型应用           | 复杂事务处理（OLTP）              | 分布式协调、配置管理               |

---

## # 关键区别
- 版本号作用：
  - MySQL 的版本是事务粒度的，用于判断数据可见性。
  - etcd 的版本是全局逻辑时钟，用于追踪整个系统的状态变化。
- 写冲突处理：
  - MySQL 依赖锁机制，可能导致阻塞。
  - etcd 通过 Raft 共识算法确保写入顺序，天然避免冲突。
- 历史查询：
  - MySQL 需要显式使用 `SELECT ... AS OF`（仅企业版支持时间点查询）。
  - etcd 直接支持按 `revision` 查询任意历史版本。

两者的 MVCC 实现反映了数据库（事务处理）和分布式系统（一致性协调）的不同设计哲学。

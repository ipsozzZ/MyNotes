## # 命令基本格式 ##

<h3 style="background-color:red; color: #fff">linux中一切的文件后缀名都只是为了方便记忆，linux没有文件后缀的概念，不依赖文件的后缀名来区分文件</h3>

### '>' 输出重定向 ###

单个(>)：将重定向的对象中的所有内容替换为当前控制台输出的内容；<br />
两个(>>): 将当前控制台输出的内容写入到重定向对象的最后一行 <br />
<br />

[root@localhost ~]# : []没有特殊含义格式符， root当前用户，@没有特殊含义，localhost代表当前的主机名，~该位置放当前目录（~是家目录），#超级用户的标识，普通用户标识是$。<br/>

命令pwd：显示当前所在位置。<br/>

## # 文件属性相关命令 ##

文件类型表示（-：文件，d：目录，l：软链接文件）<br/>

文件权限：r: 读，w: 写，x: 执行<br/>

一个文件的详细信息表示：<br/>
文件类型标识 + 文件所有者权限 + 所有者所属组权限 + 其他人权限  文件所有者+ 文件所属组+ 其他人  最近修改时间  文件名。<br/>


### ls指令 ###

ls [选项] [文件或目录]  命令ll：就是 ls -l 的别名<br/>

选项：<br/>
-a: 显示所有文件，包括隐藏文件<br/>
-l: 显示详细信息<br/>
-ld: 查看目录属性<br/>
-d: 查看目录属性<br/>
-h: 人性化显示文件大小<br/>
-i: 显示inode<br/>

### 文件相关指令 ###

创建ipso文件目录：mkdir ipso<br/>
创建china/ipso文件目录： mkdir -p china/ipso  // (-p递归创建)<br/>
<br />

cd -: 回到上次切换的目录<br/>

>linux是可以实现目录补全和命令补全的。如 cd / + 单击tab键会将/下的目录全部列出来 ，双击是将可能补全的命令列出来，不管是目录还是命令只有一条的化就直接补全不再列出。<br/>

pwd命令：打印当前目录位置
<br />

删除一个空目录：rmdir 目录名  ，不能删除非空目录，所以一般不用这条命令<br/>
删除一个文件：rm 文件名，会询问是否删除<br/>
删除一个目录包括目录下的所有文件和目录：rm -r 目录名，会每删一个文件或者目录就询问一次是否删除，删文件也可以用-r<br/>
不询问方式删除一个目录包括目录下的所有文件和目录：rm -rf 目录名，其中f就是强行将每次的询问否掉，因为删了无法恢复谨慎<br/>
<br />

cp命令：复制命令<br/>
复制一个文件：cp 文件名 复制到哪<br/>
复制一个目录：cp -r 文件名 复制到哪<br/>
cp命令的选项：<br/>
-r: 复制目录<br/>
-p: 连带文件属性复制<br/>
-d: 若源文件是链接文件，则复制链接属性<br/>
-a: 相当于 -pdr ,所以一般使用-a就可以<br/>
<br />

mv命令：剪切或者改名命令 （文件和目录都不用加 -r，如果原文件和目标文件在同一目录则为改名）<br/>
剪切一个文件（或文件夹）到同目录的ipso目录下：mv 原文件(目录)名 ipso<br/>
更改一个文件（或文件夹）的名字：mv 原文件(目录)名 新文件或目录名<br/>
<br />

ln命令： 添加链接文件<br/>
选项：<br/>
-s: 创建软连接文件， 不加-s是创建硬链接,一般不用硬链接。<br/>

硬链接：硬链接和原文件都指向同一个I节点，本质就是同一个文件，删掉任何一个不影响节点所指向的内存的值，但是硬链接和原文件的区别太小，所以一般用不到这种链接，硬链接文件类型就是d,而不是l。硬链接不能跨分区，不能链接目录。<br/>

软链接：类似于windows的快捷键方式，软链接和原文件具有不同的I节点，原理是软链接的I节点指向的内存的值是原文件的I节点，删掉原文件，软链接就不能用了，软链接的权限都是：rwxrwxrwx，但是具体的文件权限需要采纳原文件的权限，软链接的文件类型是l。原文件必须写绝对路径，相对路径只能在同一目录下才能找到，跨目录就会报错，所以习惯上就必须写绝对路径了。<br/>
<br />

### 文件搜索命令 ###

文件搜索命令locate: locate 文件名 （在/var/lib/mlocate中搜索），/var/lib/mlocate大概每天更新一次，也可以用命令updatedb命令强制更新<br/>
在后台数据库中按文件名搜索，搜索速度更快，只能搜索文件名，不能搜索更复杂的内容（遵循/etc/updatedb.conf配置文件的规则）
<br/>

命令搜索命令whereis与which （遵循/etc/updatedb.conf配置文件的规则）<br/>
whereis 命令名  ：搜索命令所在路径及其帮助文档所在位置，<span style="color:red">找不到执行文件的命令都是linux或shell内部命令</span><br/>
命令选项：<br/>
-b: 只查找可执行文件；<br/>
-m: 只查找帮助文件。<br/>

which 命令名  ：搜索命令所在路径以及文件别名（与whereis非常相似，只是which是  别名的查询）<br/>
<br/>

文件搜索命令find：功能强大，选项很多，多用就会熟悉常用的命令。<br/>
find命令：find [搜索范围] [搜索条件] ，搜索范围尽量小，如果没有使用通配符将会精确搜索 <br/>
典型例子： <br/>
find /root -name "ab[cd]"  // 搜索root下abc或abd文件或目录 <br/>
find /root -name "*[cd]"  // 搜索root下以c或d结尾的文件或目录<br/>
find /root -iname "ab*"   // 不区分大小写搜索ab开头的所有文件或目录<br/>
find /root -user root     // 按所有者为root在root目录下搜索文件，这个意义不大<br/>
find /root -nouser root   // 按不是所有者不是root的条件在root目录下搜索文件，如果发现搜索到的文件是在/sys或者/tmp下，它有可能是内核产生的，不用动，如果不是在用户的u盘里的话就可以将搜索到的文件删除了。（清理垃圾文件常用）
<br/>
知识整理：<br/>
atime 文件访问时间；ctime 改变文件属性的时间；mtime 文件修改时间<br/>
-10 10天内操作文件；10 10天当天操作文件；+10 10天前操作的文件；默认是天，也支持其它单位，如分钟等<br/>

find /var/log/ -mtime +10  #查找10天前修改的文件 // 常用来删除日志等 <br/>
find [搜索范围] -size [文件大小num] // 搜索某范围内大小num的文件<br />
知识整理：<br />
-25k 小25k；25k 等于25k；+25k 大于25k。(记得'k'是小写，换大写则报错，如果以M为单位，M必须大写，换小写报错)；如果不写单位则默认单位是"块"(linux逻辑上把内存用同心圆加扇形组成的公共区称扇区，作为一个内存块，大小为512字节)，大小是我们给的数字乘以512字节，所以不带单位换算起来很麻烦。
<br/>
通过I节点来搜索文件：<br/>
find [文件范围] -inum [I节点号] <br/>
逻辑判断：<br/>
-a: and 逻辑与，两个条件都满足 <br/>
-o: or  逻辑或，满足条件之一 <br/>
find [搜索范围] [选项] [条件1] -a [选项] [条件2] <br/>
find [搜索范围] [选项] [条件1] -o [选项] [条件2] <br/>

知识整理：<br/>
<strong>执行两条命令：命令1 -exec ls -lh {}\;  第二条命令是 "-exec 第二条命令 {} \;" <strong/>(注意{}、\之间有空格不能省) ,执行完第一条命令结果交给第二条命令执行 <br/>
<br/>
字符串搜索命令grep：在文件中匹配符合条件的字符串 <br/>
命令grep: <br/>
格式：grep [选项] 字符串 文件名 <br/>
选项： <br/> 
-i: 忽略大小写 <br/>
-v: 排除指定的字符串 <br/>
<br/>

find命令与grep命令的区别
find命令：在系统当中搜索符合条件的文件名，如果需要匹配，使用通配符匹配，通配符是完全匹配。<br/>
grep命令: 在文件当中搜索符合条件的字符串，如果需要匹配，使用正则表达式进行匹配，正则表达式时也是包含匹配<br/>
<br/>

### linux中的帮助命令 ###

#### man帮助命令 ####

man命令：<br />
格式：man + [对象] （对象可以是命令或者函数等）<br/>

man帮助命令的等级：
1 ：查看命令的帮助<br/>
2 ：查看可被内核调用的函数的帮助 <br/>
3 ：查看函数和函数库的帮助 <br/>
4 ：查看特殊文件的帮助(主要是/dev下的目录，也就是设备目录) <br/>
5 ：查看配置文件的帮助 <br/>
6 ：查看游戏的帮助 <br/>
7 ：查看其它杂项的帮助 <br/>
8 ：查看系统管理员可用命令的帮助 <br/>
9 ：查看和内核相关文件的帮助 <br/>
<br />

查看命令拥有哪些级别的帮助：<br />
man -f 命令; 相当于 whatis 命令 <br />
列举：
man -f 命令 查看所有命令级别 <br />
man 5 passwd <br />
man 4 null <br />
man 8 ifconfig <br />
<br />

查看和命令相关的所有帮助 <br />
man -k 命令  相当于 apropos 命令 <br />
<br />

#### linux中的其它帮助 ####
命令 --help : 获取命令选项 <br>

help 命令  ：获取内部命令的帮助，这里的命令必须是内部命令，否者报错
<br /> <br />

info详细帮助命令：<br />
格式：info 命令  进入以后有一下操作<br />
+回车：进入子帮助页面（带有*号标记）<br />
+u: 进入上层页面 <br />
+n: 进入下一个帮助小节 <br />
+p: 进入上一个帮助小节 <br />
+q: 退出 <br />
<br />

### linux压缩与解压缩命令 ###

常用的压缩格式：.zip .gz .bz2 .tar.gz .tar.bz2 <br />
zip格式压缩：可以和windows公用<br />
文件压缩：zip 压缩文件名 源文件 <br />
目录压缩：zip -r 压缩文件名 源目录 <br />
文件或目录解压缩：unzip 压缩文件名 <br />
<br />

gzip格式压缩： 压缩为.gz的压缩文件，源文件消失。可以在windows中解压缩, 但是windows中的.rar压缩文件不能在linux中解压缩 <br />
格式： gzip 源文件   (压缩完之后源文件就不在了) <br />
源文件不消失：gzip是不支持源文件不消失的压缩方式的，但是我们可以利用文件重定向强行将原文件留下，这个不怎么用 <br />
知识点整理：'>' 输出重定向 <br />
所有原文将不消失的方法：gzip -c 源文件 > 压缩文件  (这里的逻辑并不是让gzip保留了源文件，而gzip -c是会把压缩文件输出而且保留源文件, 然后我们只需要将输出的内容重定向到压缩文件就可以了) <br />
格式：gzip -r 目录  (只是将目录下的所有子文件压缩，并没有将整个目录压缩，有解决办法)<br />
gzip格式解压缩：<br />
gzip -d 压缩包  <br />
gunzip 压缩包   <br />
<br />

bz2格式压缩： 注意bz2不能压缩目录 <br />
文件压缩：bzip2 源文件  （不保留源文件） <br />
保留源文件压缩：bzip2 -k 源文件 <br />
bzip2格式解压缩：<br />
格式： <br />
bzip2 -d 压缩包  （-k 保留压缩包）<br />
bunzip2 压缩包 （-k 保留压缩包） <br />
<br />

.tar.gz 和 .tar.bz2格式压缩：常用<br />
起因：因为.gz 和 .bzip2格式的压缩格式对目录的压缩支持不怎么友好甚至，不能压缩目录，所以就有了.tar.gz和.tar.bzip2压缩。<br />
原理：将目录或者文件打包为.tar文件，再进行压缩。<br />
打包命令tar：<br />
格式：tar -cvf(选项) 打包文件名 源文件 <br />
选项：-c打包；-v显示过程；-f指定打包后的文件名 <br />
解打包：tar -xvf 包名 <br />
打包加压缩一起操作：<br />
压缩为.gz格式：tar -zcvf 压缩文件名 源文件名 源文件名 ... (可以压缩多个文件或目录，空格隔开就可以)<br />
解压缩.gz格式：tar -zxvf 压缩文件名 -C(注意这里是大写，可选位置不能乱) 解压到的位置 <br />
查看压缩包.gz格式：tar -ztvf 压缩文件名 <br />
压缩为.bz2格式：tar -jcvf 压缩文件名 源文件名 源文件名 ... (可以压缩多个文件或目录，空格隔开就可以)<br />
解压缩.bz2格式：tar -jxvf 压缩文件名 -C(注意这里是大写，可选位置不能乱) 解压到的位置 <br />
查看压缩包.bz2格式：tar -jtvf 压缩文件名 <br />
<br />

### linux关机和重启命令 ###

1. shutdown命令
   说明：远程服务器不要轻易使用关机和重启命令，特别是关机命令，因为远程服务器主机不在身边启动不方便是一方面，另外就是远程服务器处于高速运转，关机重启都有可能导致服务器磁盘摔坏，数据丢失等，特别是关机命令。shutdown命令较长，但是相对安全。一般都用该命令操作。 <br />
   格式： shutdown [选项] 时间 <br />
   选项：-c取消前一个关机命令；-h关机；-r重启。<br />

2. 其它关机命令(了解就好，一般不能使用，还是要用shutdown命令)
   halt：关机命令 <br />
   poweroff: 关机命令 <br />
   init 0: 关机命令 <br />

3. 其它重启命令
   reboot: 重启命令 (相对安全，不想用shutdown的话，可以使用该命令代替) <br />
   init 6: 重启命令 (了解，不建议使用) <br />

4. 退出登录：logout   (如果远程登录服务器不退出登录而是直接关掉对话框的话，登录状态会一直卡着处于登录状态，虽然linux允许用户多地登录，但是也是有上限的，有的是250次左右，但是windows服务器就不一样，它最多的也就几个不超20个，有的甚至就1个，如果登录次数用完就要重启或者关机重开，这对于服务器来说是不允许因为这样的失误而重启的。所以我们要养成使用logout退出登录的好习惯)
<br /> <br />

### 挂载命令(类似于windows的分配盘符) ###

注：分区后必须要挂载才能使用分区，如果是硬盘的分区建议将挂载信息写入挂载配置文件/etc/fstab中，这样下次关机重启后系统就会自动挂载分区，否侧下次启动分区
1.查询与自动挂载
mount : 查询系统中已经挂载的设备 <br />
mount -a:依据配置文件/etc/fstab的内容，自动挂载一遍文件中设置为默认挂载的设备 <br />
挂载命令格式：mount [-t 文件系统] [-o 特殊选项] 设备文件名 挂载点 <br />
选项： <br />
-t: 文件系统，加入文件系统来指定的挂载类型，如ext3、ext4、xfs，iso9660(光盘使用的文件系统)等文件系统，如果支持尽量xfs，它效率更高，是centos7后的文件系统，可以不写，有默认的<br />
-0: 特殊选项，可以指定挂载的额外选项，这里特殊的选项非常的多，用的时候可以查看文档，一些常用的如exec/noexec(可执行/不可执行，默认是可执行)以及rw/ro(读写/只读，这里默认是读写)等可以记下，多个特殊选项可以用逗号隔开，尽量不要改<br />

### 硬盘分区 ###

注：这里的硬盘指的是使用linux支持的文件系统的硬盘，而不是NTFS这种windows常用的文件系统 <br />
首先插入硬盘，VM的话是关机后，配置里面加，正真的实体机的话不用关机，支持热插入的，插入后直接可以使用fdisk相关命令查看，下面介绍从分区到挂载到使用的过程。 <br />

#### MBR分区表模式 ####

fdisk命令：MBR模式分区，分区后类型是dos <br />
格式：fdisk 设备文件名：这是进入分区模式，如：fdisk /dev/sdb    (选择sdb这块硬盘并进入分区模式) <br />
进入分区模式后，可以使用m命令查看帮助菜单，简单的列几个命令(d删除一个命令，n新建一个命令，这些命令都是跟着提示做下去就可以完成) <br />

知识普及： <br />
分区模式分类： <br />
分区模式之MBR模式： <br />
-- 主分区4个，一个扩展分区，1个逻辑分区 <br />
-- 单个分区容量最大2TB <br />
<br />
分区模式之GPT模式： <br />
-- 主分区个数"几乎"没有限制 (主分区有128个，一般就不分扩展分区了，但是还是有这个概念的有可能是为了兼容MBR模式) <br />
-- 单个分区容量"几乎"没有限制 (每个分区最大可达18EB，18EB=1024PB,1PB=1024TB,1TB=1024GB) <br />
缺点：GPT主分区中，不适合安装X86架构的系统
<br />

#### GPT分区表模式 ####

注：查看硬盘信息照样使用fdisk命令 <br />

使用命令parted: 既可以做MBR模式分区，也可以做GPT模式分区 <br />
格式：parted: 这是进入了分区模式了，可以使用help命令来查看帮助菜单，这里命令和fdisk有点区别，但是结果都是获取帮助菜单，默认分区是第一块硬盘，也就是sda1，可以使用命令'select 设备文件名'来切换硬盘，这在帮助文件中也有介绍。<br />
和fdisk的区别：parted需要使用'mklabel msdos'(MBR模式)或者'mklabel gpt'(GPT模式)。 <br />
具体流程： <br />
parted进入分区模式，使用select选择需要分区的硬盘，接下使用mklabel选择模式(msdos是MBR模式，gpt是GPT模式)，接下来选择是交互是分区还是命令模式分区(交互式就是系统一步步提示完成分区，命令模式就是直接输入命令回车完成) <br />
注意：在分区的开始位置设置时，如果是第一个分区，不要从0(单位默认是M)开始，要从1开始，这是为什么呢，这和4k(一个簇)对齐是一个道理。原理就是牺牲掉63个扇区(每个扇区512字节，63个也就是8个簇多一点)，这样文件系统在读写某个簇(默认定义为4096字节大小为一个簇)的时候，硬盘就不需要读写两个物理单元,以避免过多的读写操作，从而延长硬盘寿命和提升硬盘效率，具体可以自行百度，这回扯到很多东西。如果以0开始系统会报一个警告错误 <br />
具体的分区的过程来个例子： <br />
当前有8G的硬盘未分区也为挂载/dev/adc  <br />
使用GPT模式分区：分区后类型是gpt<br />
使用GPT模式的交互模式分区：<br />
\# parted <br />
(parted) select /dev/sdc <br />
(parted) mklabel gpt <br />
(parted) mkpart <br />
partitionn name? []? partname <br />
file system type? [ext2]? typename <br />
Start? 1 <br />
End? 2000   #到这里就完成了 <br />
(parted) 用print查看当前硬盘分区的状况(print all 查看所有硬盘分区情况) <br />
分区结束 <br />
<br />
使用GPT模式的命令模式分区：<br />
\# parted  <br />
(parted) select /dev/sdc  <br />
(parted) mklabel gpt  <br />
(parted) mkpart 分区名称 分区开始位置 [分区结束位置]   <br />
分区结束  <br />
注：分区重叠的话系统会提示，跟着提示操作就好了。parted进入分区的模式，删除分区的命令是：rm 分区的Number, 如：rm 2  (指删除Number号为2的分区，怎么查看Number号，print命令就可以)

注：分区的大小单位可以通过unit 单位  的方式修改，如: unit GB

注：使用命令parted分区不需要像使用fdisk命令那样需要用w命令来保存分区，parted命令的分区直接实时保存了 <br />
<br />

### 分区格式化 ###

命令：<br />
mkfs.文件系统名 设备文件名： 如：mkfs.xfs /dev/sda1 (将sda1分区格式化为xfs文件系统格式)

mkfs -t 文件系统名 设备文件名： 如：mkfs -t xfs /dev/sda2  (将sda2分区格式化为xfs文件系统格式)

注：扩展分区和逻辑分区不能被这种命令格式化，只有主分区可以，分区结果可以进入parted后用print指令查看
<br />

### 添加swap分区 ###

1. 建立一个普通linux分区(是linux分区，不是extended扩展分区)
2. 修改分区类型的16进制编码
3. 格式化swap分区
4. 启用swap分区

第一步不说了，这里用已有的分区演示

第二步：用fdisk 硬盘名，进入硬盘分区，输入t选择选择要修改的分区编号，然后可以使用L查看编码列表，找到swap对应的编号，然后输入该编号，最后w保存退出fdisk界面。

第三步格式化分区：格式化的格式与正常格式化格式不一样：使用mkswap 分区名，如：mkswap /dev/sdb5

第四步启用swap分区，使用: swapon 分区名，如：swapon /dev/sdb5

最后通过free命令查看swap状况

注：停用swap分区：swapoff swap分区名，如：swapoff /dev/sdb5

### 挂载光盘 ###

光盘的设备文件名：系统设定，在/dev/sr0 软链接是：/dev/cdrom，两个用谁都行。
建立挂载点：mkdir /mnt/cdrom/    (挂载点只要在空目录下就可以，但是规范一点的话就应该在media或者music或者mnt目录下建立新的目录作为挂载点)<br />
挂载光盘：mount -t iso9660 /dev/cdrom(注：设备文件名) /mnt/cdrom/(注：挂载点)  (这里没有使用到-o特殊选项，我们挂载的时候正常情况也不用写，这里还可以省略-t指定文件系统选项，因为很有默认的文件系统) <br />
弹出光盘：卸载光盘：umount 设备文件名或者挂载点    (弹出设备必须的操作) <br />
<br />

### 挂载U盘 ###

插入U盘后用fdisk -l命令查看U盘设备文件名(一般是sdb1，具体使用命令查看) <br />
建立挂载点：mkdir /mnt/usb <br />
挂载U盘：mount -t vfat(即FAT32,采用32位的文件分配表，支持最大分区128GB,支持最大文件4GB,常见于U盘中) /dev/sdb1 /mnt/usb/  <br /> 
注：linux系统默认是不支持NTFS(windows主要的文件系统)文件系统的，但是可以通过重新编译linux内核来支持NTFS文件系统，为什么没有默认，原因是这样的，linux在编译内核的时候把一些它认识常用的驱动都装上了，但是把有所驱动都装内核的话，内核会非常的大，所以有一些驱动linux是没有装的，比如NTFS文件系统，而windows是直接什么都没有装，装好系统后手工安装设备驱动。此外还可以通过安装ntfs-3g来支持NTFS文件系统，这要比重新编译内核容易得多，在挂载移动硬盘是要考虑到得问题，但是不管是那种方式对于NTFS文件系统的文件来说也只拥有只读属性，并不可写入。所以一般在windows上的文件都是通过网络来和linux系统之间进行文件传输的，很少挂载移动硬盘的操作。<br />
<br />

### 用户登录查看常用命令 ###

1. 查看用户登录信息： <br />
   命令：w 用户名 <br />
   命令输出： <br />
   USER: 登录用户名；
   TTY: 登录终端； (tty1：表示第一个本地登录用户，pts/0:表示第一个远程终端)
   FROM: 从哪个IP地址登录的；
   LOGIN@: 登录时间；
   IDLE: 用户闲置时间；
   JCPU: 指的是和该终端连接的所有进程占用的时间。这个时间里并不包括过去的后台作业时间，但却包含当前正在运行的后台作业所占用的时间  <br />
   WHAT: 当前正在运行的命令。 <br />

	 who命令：查看登录用户，信息没有w全 <br />

2. last命令查看当前登录和过去登录的用户信息(显示系统中所有的用户登录信息，如果有不是自己授权或者不是自己登录的记录，应该注意是不是有黑客登录过) <br />
   格式：last <br />
   注：last命令默认是读取/var/log/wtmp文件数据(该文件的内容是二进制格式，只能通过last命令查看，不能用vi等查看，这是防止数据被改动) <br />
   命令输出：<br />
   用户名 <br />
   登录终端 <br />
   登录IP <br />
   登录时间 <br />
   退出登录时间(在线时间) <br />

3. lastlog命令：查看系统的所有用户的最后一次登录信息，不管有没有登录过 <br />
   格式：last <br />
   注：last命令默认是读取/var/log/lastlog文件数据 (该文件的内容是二进制格式，只能通过last命令查看，不能用vi等查看，这是防止数据被改动) <br />
   命令输出：<br /> 
   用户名 <br />
   端口 <br />
   登录IP <br />
   最后登录时间 <br />


### $PATH环境变量 ###

$PATH环境变量：定义的是系统搜索命令的路径（如果执行的命令或者脚本程序想要不打绝对路径就执行的话，就一定要将它们放在在$PATH路径中）<br/>
当使用一条命令时系统会在$PATH路径里寻找该命令的位置，找到的话就执行，找不到就报'command not found'(命令没有被发现错误) <br/>

$PATH结构: '每两个绝对路径之间冒号相连' <br/>

### linux中的通配符 ###

*：匹配任意内容 <br/>
?：匹配任意一个字符 <br/>
[]: 匹配任意一个中括号内的字符 <br/>

### linux中的修改权限命令 ###

chmod [数字表示的权限，如755等] 文件名

### linux中的查看当前用户 ###

whoani

### linux中的文件所有者 ###

除了外来文件和部分系统内核文件外，文件都会有所有者，没有所有者就相当于垃圾文件，应该手动将其删除 <br/>
外来文件：我的文件是在windows中拷贝到u盘的，u盘中插入linux的文件就有可能没有所有者，windows忽略了文件所有者，但不是没有文件所有者 <br/>
系统内核文件：内核产生的文件调用是不经过系统目录的，内核直接调用，如/sys、/tmp目录里的部分文件就是系统内核文件，其中就有部分文件没有所有者 <br/>
<br />

### 系统运行级别 ###

0：关机 (不允许设为默认级别)
1：单用户 (类似windows的安全模式，启动最小的程序，主要是做系统修复，比如说忘记密码了，就可以通过单用户修复)
2：不完全多用户，不含NFS服务 (字符界面，但是不包含NFS服务，NFS服务是linux中的一个文件共享服务)
3：完全多用户 (字符界面，包含NFS服务，NFS服务是linux中的一个文件共享服务，我们平时使用的字符界面就是完全多用户，包含NFS服务)
4：未分配
5：图形界面 (linux中使用大写的X代表图形界面)
6：重启 (不允许设为默认级别) <br />

注：可以通过'init 0~6'来调用其它系统级别 <br />
查看当前运行级别：runlevel    运行结果：上次运行级别 当前运行级别 <br />
修改系统默认的运行级别：可以在'/etc/inittab'中设置
<br />

### linux磁盘 ###

使用count命令查看挂载设备的情况：
其中我们在安装linux时的分区在/dev/下：
/dev/sda5 on / type xfs (rw) ……    （sd是linux的硬盘接口，a是第一块硬盘，b是第二快以此类推，5是分区号，第五个分区，也是第一个逻辑分区，'/'是根分区，xfs是所使用的文件系统，rw是权限。sda1等类似）<br />
此外：/proc 和 /sys 是内存的挂载点，是系统内核自动挂载的，不要乱动，还有一些其它的临时挂载设备也不要乱动。<br />
<br />

### 在linux上写脚本文件 ###

#!/bin/bash  (这行不是注释，不可省略，它告诉linux这是linux标准脚本文件，普通的Linux脚本没有这句话是可以执行的，但是如果使用一些复杂的语言的话没有这个是执行不了的，所以这行代码是必须的，不是可选) <br />
#这里是注释内容 <br />
~ <br />
~ <br />
~ <br />
~ <br />
注： 可以使用':quit!' 命令强行退出vim，尽量不要用，除非正常的q退不出来时再用。

## # shell基础 ##

### shell概述 ###

命令解释器；还是一个功能相当强大编程语言
Shell的两种主要语法类型有Bourne Shell 和 C Shell，这两种语法彼此不兼容。Bourne家族主要包括sh(很古老了)，ksh，Bash(当前linux主要使用,linux中的标准shell)，psh，zsh;C（语法类似c语言，所以叫c Shell，主要给Unix用）家族主要包括：csh，tcsh。
可以在/etc/shells文件中查看当前系统使用的shell类型相兼容的shell类型。可以使用vi查看 <br />

我们不仅可以有当前shell,还可以调用其它类型的shell,也可以调用相同类型的shell,只是相同类型的shell叫子shell,还可以在子shell里又调用子shell。又是会用到这样的操作。<br />

### 脚本执行方式 ###

1. echo输出命令：将指定内容输出到屏幕上，还可以识别字颜色 <br />
   格式：echo [选项] [输出内容] <br />
   选项： <br />
   -e：支持反斜线控制的字符转换，-e主要是用于格式控制 <br />
   例：echo -e "hello\tworld"  (解释：输出“hello world!”,其中'\t',是加tab的意思，这里-e就不能省了) <br />
   例：echo -e "\e[1;31m 这是颜色识别测试 \e[0m" (解释：用红色字体颜色输出文字，'\e[1;'加颜色代码开始，以'\e[0m'结束) <br />
   <br />

2. 第一个脚本
   不再演示；

3. 执行脚本  <br />
   两种方法： <br />
   a. 赋予执行权限，直接执行。（正常思路） <br />
      chmod 755 hello.sh <br />
      ./hello.sh <br />
   b. 通过bash调用执行脚本。
      bash ./hello.sh （这种可以不用给执行权限, 执行文件必须带文件路径（可以是相对路径或者绝对路径），如果是当前位置，就只用文件名也可以） <br />
<br />

### bash基础 ###

#### 命令别名与快捷键 ####

注：别名一般不与系统已有的命令的冲突，除非是为了覆盖原有的命令 <br />

1. 查看系统中的别名 <br />
   命令：alias  （该命令用于查看当前系统中生效的别名）

2. 设定命令别名 (临时生效，重启后就失效)<br />
   命令：alias 别名='原命令' <br />
   例：<br />
   系统中默认的部分别名设定有：<br />
   alias rm='rm -i'   （这样我们在使用rm 文件名 进行删除文件时就相当于执行rm -i 文件名，-i的作用是询问是否删除，防止误删），系统还有其它的一些别名设定，可以使用alias查看<br />

3. 别名永久生效与删除别名
   别名永久生效：用vim或者vi(这里注一下，vim更强大)将设置别名的命令写入环境变量配置文件(该文件每个用户都会有一个，位置在用户目录里，文件名是'.bashrc',不止这一个环境配置文件)，更新了.bashrc后默认重新启动后生效，也可以使用命令(source .bashrc)立即生效。<br />
   删除别名：unalias 别名   (这是删除临时别名，如果.bashrc文件还有的话，下次启动本次删除的别名还会生效，要永久删除就需要在.bashrc中也要删除) <br />

4. 命令生效顺序 <br />
   a. 第一顺位执行用绝对路径或相对路径执行的命令。 <br />
   b. 第二顺位执行别名。 <br />
   c. 第三顺位执行Bash的内部命令。 <br />
   d. 第四顺位执行按照$PATH环境变量定义的目录查询顺序找到的第一个命令。 <br />
<br />

## # 常用快捷键 ##

Ctrl + c : 强制终止当前命令. <br />
Ctrl + l : 清屏。(clear命令也是清屏) <br />
Ctrl + a : 光标移动到命令行首。<br />
Ctrl + e : 光标移动到命令行尾。<br />
Ctrl + u : 从光标位置删除到行首。 <br />
Ctrl + z : 把命令放入后台。（命令并没有终止，只是放入后台运行，所以尽量不要用，否则后台命令多了系统占用的系统资源也就越多） <br />
Ctrl + r : 在历史命令中搜索。<br />

## # 其它 ##

### 历史命令 ###

查看格式：history [选项] [历史命令保存文件] <br />
选项： <br />
-c : 清空历史命令 <br />
-w : 把缓存中的历史命令写入历史命令保存文件(/root/.bash_history)  (不用这个命令的话，需要重启等操作以后才写入)<br />

常用的两种历史命令的调用：<br />
使用上下箭头调用；使用"!字符串"，重复执行最后一条以该字符串开头的命令 <br />


### 输出输入重定向 ###

#### 系统黑洞 '命令 &>/dev/null' (不需要看某个命令的输出结果) ####

#### 输出重定向 ####

正确输出重定向：<br />
单个(>)：将重定向的对象中的所有内容替换为当前控制台输出的内容；<br />
两个(>>): 将当前控制台输出的内容写入到重定向对象的最后一行 <br />
错误输出重定向(注意：右边没有空格)：<br />
单个(2>)：将重定向的对象中的所有内容替换为当前控制台输出的内容；<br />
两个(2>>): 将当前控制台输出的内容写入到重定向对象的最后一行 <br />
<br />

正确输出和错误输出都实现重定向：（最常见）<br />
格式1：命令 >> 文件 2>&1  (注：以追加的方式将正确或者错误的输出写入同一个文件，覆盖的格式类似) <br />
格式2：命令&>>文件  (注：以追加的方式将正确或者错误的输出写入同一个文件，覆盖的格式类似) <br />
格式3：命令>>文件1 2>>文件2 (注：以追加的方式将正确的输出写入文件1，将错误的输出写入文件2) <br />


#### 输入重定向(基本用不到) ####

格式：wc [选项] [文件名]  <br />
选项：<br />
-c : 统计字节数 <br />
-w : 统计单词数 <br />
-l : 统计行数 <br />

输入重定向：wc < 文件名 (列出文件的行、单词、字符数) <br />


### 管道命令 ###

#### 多命令执行顺序 ####

多命令执行符： <br />
';'  : 多个命令顺序执行，没有逻辑关系，格式：命令1; 命令2 <br />
'&&' : 逻辑与，当命令1正确执行，才会执行命令2，否则不执行命令2，格式：命令1&&命令2 <br />
'||' : 逻辑或，当命令1执行不正确，命令2才执行，否则不执行命令2，格式：命令1||命令2 <br />
'|'  : 管道符，命令1的正确输出作为命令2的执行对象，注意后面的命令一定要可以执行前一条命令的结果，否则就会报错， 格式：命令1|命令2 <br />
管道符例子：netstat -an | grep ESTABLISHED | wc -l  （可以让我们知道当前有多少人连接我们的系统）<br />
例子解析：<br />
netstat -an: 查看当前系统中的网络连接情况，其中state为LISTEN指的是端口被监听，等待网络访问，state为ESTABLISHED指的是系统被远程访问 <br />
grep ESTABLISHED: 查询包含字符串'ESTABLISHED'的行 <br />
wc -l: 统计行数 <br />

扩展知识：more(分屏显示文件内容)、netstat -an 查看当前系统中的所有网络连接<br />


### 通配符 ###

#### 一般 ####

\*: 匹配所有  <br />
? : 匹配一个字符 <br />
[]: 匹配中括号中的任意一个字符 <br />

#### 特殊符号 ####

'' : 单引号，在单引号中的所有特殊符号，如"$"和"`(反引号)"等都当作普通字符处理。 <br />
"" : 双引号，在双引号中特殊符都没有特殊含义，但是"$" 、"`"、"\"是例外，分别是"调用变量的值"、"应用命令"、"转义符"的含义。<br />
`` : 反引号，反引号括起来的内容是系统命令，在bash中会先执行它。和$()作用一样，不过推荐使用$()，因为反引号容易看错。<br />
$(): 和反引号的作用一样。<br />
\# : 在shell脚本中，#开头的行代表注释 <br />
$  : 用于调用变量的值，格式：$变量名。 <br />
\  : 转义符，跟在\后的特殊符号将失去特殊含义，变为普通的字符。<br />

## # vim ##

#### 未进入文件前常用命令 ####

vim 文件名：创建文件或者打开文件 <br />
vim 文件名1 文件名2 文件名3 ……：创建文件或者打开多个文件(默认进入文件名1文件，在底行模式中使用:n换行来进入打开的下一个，使用N(或者:prev换行)换行来进入打开的上一个文件) <br />
vim +n 文件名: 创建或者打开文件并将光标定位到第n行 <br />
vim +/xxx 文件名：打开文件后将光标定位在字符串'xxx'第一次出现所在的行，如果有多行可以用n切换行。 <br />

#### 命令模式常用命令 ####

(注：进入以后，在命令模式下使用'd'指令删除第一行) <br />
h: 光标左移 <br /> 
j: 光标下移 <br />
k: 光标上移 <br />
l: 光标右移 <br />
ctrl + f: 向下翻页(front) <br />
ctrl + b: 向上翻页(back) <br />
ctrl + d: 向下翻半页(down) <br />
ctrl + u: 向上翻半页(up) <br />
dd: 删除光标所在行 <br />
o : 在光标所在行的下方插入一行并切换到输入模式 <br />
yy: 复制光标所在行 <br />
p : 在光标所在行的下方粘贴 <br />
P : 在光标所在行的上方粘贴(这里是大写的P) <br />


#### 底行模式常用命令 ####

注：在底行模式中使用:ls查看当前打开的所有文件 <br />
注：在底行模式中使用:x将光标快速跳转到x行 <br />
注：在底行模式中使用/xxx从光标位置开始定位到字符串xxx第一次出现的位置，并将光标移到该位置 <br />
注：在底行模式中使用?xxx从光标位置向前定位到字符串xxx第一次出现的位置，并将光标移到该位置 <br />


## # 磁盘管理 ##

查看磁盘信息： <br />
命令：df [选项] [条件] <br />
选项： <br />
-l : 仅显示本地磁盘(默认) <br />
-a : 显示所有文件系统的磁盘使用情况，包含比如/proc/ <br />
-h : 以1024进制计算最合适的单位显示磁盘容量 <br />
-H : 以1000进制计算最适合的单位显示磁盘容量 <br />
-T : 显示磁盘分区类型 <br /> 
-t : 显示指定类型文件系统的磁盘分区 <br />
-x : 不显示指定类型文件系统的磁盘分区 <br />
例：df -aht xfs   (解析：查看所有文件系统为xfs的磁盘分区，并将其大小以1024进制计算显示) <br />
<br />

统计磁盘上的文件大小
命令：du [选项] [条件]
选项：
-b : 以byte为单位统计文件
-k : 以KB为单位统计文件
-m : 以MB为单位统计文件
-h : 以1024进制计算最合适的单位统计文件
-H : 以1000进制计算最合适的单位统计文件
-s : 指定统计目标

## # linux中的用户和用户组 ##

用户：使用操作系统的人

用户组：具有相同系统权限的一组用户

/etc/group 文件存储当前系统中所有用户组信息

取文件中的一行出来分析：

Group:x:123:abc,def:

group: 组名称

x: 组密码占位符

123：组编号

abc,def：组中的成员

注：如果组成员位置为空，不代表没有组员，如果组员名称和组名一样的话，系统默认不显示该


/etc/gshadow 该文件储存当前系统中用户组的密码信息。

取一组分析：

group:*: :abc,def

group: 组名称

*：组密码  (当组密码为：'*','!',''时认为组密码为空)

 ：组管理者 (一般为空，意思时组内所有成员都可以管理这个组)

abc,def: 组成员

<br />

/etc/passwd 该文件储存当前系统中所有用户的信息

取一行出来分析：

user : x : 123 : 456 : xxxxxxxx : /home/user : /bin/bash

user: 用户名

x: 密码占位符

123：用户编号

456：用户组编号

xxxxxx: 用户注释信息

/home/user: 用户主目录

/bin/bash: shell类型

注：root的用户编号永远是0

<br />

/etc/shadow 该文将用来存储当前系统中所有用户的密码信息

取一行出来分析：

user : vf;/Zu8sdf... : : : : : :

user: 用户名

vf;/Zu8sdf...：密码 (使用单向加密算法加密的，我们无法获取到真实的原始密码)

<br />

### 创建用户组 ###

命令：groupadd 组名   （创建用户组，并使用默认的用户组编号）。

创建用户组并指定用户组编号：groupadd -g [用户组编号] 用户组名

更改用户组名：groupmod -n 新用户组名 原来的用户组名

更改用户组编号：groupmod -g 用户组编号 用户组名

删除用户组：groupdel 用户组名

在用户组中添加一个用户：useradd -g 用户组名 用户名

在用户组中添加一个用户并添加该用户的个人文件夹：useradd -d /home/xxx 用户名 (如果没有指定用户组，系统会创建一个与用户名一样的用户组)

给用户添加备注：usermod -c 备注名(用户注释信息) 原名

将某个用户名重新分配给其他人：usermod -l 新用户名 原用户名

修改某个用户的个人文件夹路径：usermod -d /home/用户名 用户名

修改用户的所属用户组：usermod -g 目标用户组名 用户名

删除用户：userdel 用户名

删除用户的时候连同用户个人文件一起删除： userdel -r 用户名

禁止普通用户登录系统：touch /etc/nologin   (只要在/etc/目录下创建nologin文件就可以，内容无关紧要，空文件都可以)

#### 用户及用户组管理进阶 ####

锁定用户：passwd -l 用户名

解锁用户：passwd -u 用户名

清除用户密码：passwd -d 用户名  (可以让该用户无密码登录)

一个用户可以属于多个用户组，有一个主用户组和多个副用户组：

将用户加入其它用户组: gpasswd -a 用户名 用户组名1,用户组2...     (创建用户是指定的用户组作为该用户的主用户组，后来加的属于附属用户组，用户可以在主用户组与附属用户组之间切换，当创建文件时会使用当前所在用户组的名义创建，默认用户是在主用户组)

主用户组与附属用户组的切换：用户使用命令'newgrp 目标用户组名称'进行用户组切换，之前学的用户组密码就是这个切换组的时候用的。如果目标组设有组密码，需要输入组密码才能切换，这是用户的操作，不是超级用户root的操作。

用户退出附属组：gpasswd -d 用户名 用户组名

在添加用户的时候指定附属组：useradd -g 主用户组 -G 附属组1,附属组2,... 用户名

设置用户组组密码：gpasswd 用户组名  (根据提示完成密码设置)

<br />

#### 其它 ####

用户切换命令：su 用户名   (不加用户名默认切换到root用户)

root 用户切换到其它用户不需要目标用户密码。

普通用户密码切换到root用户需要root用户密码

普通用户切换到普通用户也需要目标用户密码

<br />

Whoami: 显示当前用户

id 用户名：显示指定用户信息，包括用户编号、用户名、主要组编号及名称，附属组列表

groups 用户名：显示用户所在的所有组

chfn 用户名：设置用户资料，依次输入用户资料

finger 用户名：显示用户详细信息

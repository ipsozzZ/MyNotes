
# 数据库（选择题，即综合分析）

## # 概念

#### 三级模式--两级映射
内模式：管理如何存储物理的数据，对应具体物理存储文件
模式：又称概念模式，就是通常使用的基本表
外模式：对应数据库中的视图这个级别

外模式--模式映像：存在于感念级和外部级之间，若数据发生了修改，只需要修改此映射，而无需修改应用程序
模式--内模式：是表和数据的物理存储之间的映射，若修改了数据存储方式，只需要修改此映射，而不需要修改应用程序

#### 数据库设计
1. 需求分析
产出数据字典、数据流图、需求说明设等

2. 概念结构设计
产出E-R图
合并E-R图时存在的冲突主要由以下三类：
- 属性冲突：同一个属性存在不同的分E-R图中
- 命名冲突：相同名字的属性在不同E-R图中有不同的意义或者相同意义的属性，在不同E-R图中代表不同的意义
- 结构冲突：同一实体在不同的E-R图中有不同的属性

3. 逻辑结构设计
将E-R图转换成关系模式（数据库中的表结构）

4. 物理设计
确定数据分布、存储结构、访问方式等

5. 数据库实施阶段
根据逻辑设计阶段和物理设计阶段的结果建立数据库、组织数据入库，运行、调试程序

6. 数据库运行和维护阶段
后续调整、维护

#### 数据模型（数据模型三要素（考过）：数据结构、数据操作、数据的约束条件）
1. 关系模型（数据表）
2. 概念模型（E-R图）
3. 其它

#### E-R图
1. 在E-R模型中，使用椭圆表示属性、长方形表示实体（长方体多两条杠的表示弱实体，弱实体一般要依赖于强实体出现，（用小圆圈表示依赖））、棱形表示联系（联系两端要填写联系类型（1：1，1：*，*：*）*根据题意变化，N、M等都能表示多）

2. E-R模型

2. 每个实体都需要建立一张关系模型表（注意是强实体，弱实体可以是强实体中的一个属性字段）
3. 1:1 联系: 联系可以放到任意的两端实体中，作为一个属性，也可以转换位一个单独的关系模式
4. 1:N 联系: 联系可以单独一张表，也可以在N端实体中加入1端实体的主键
5. M:N 联系: 联系必须作为一个单独的关系模式，其中主键是M和N端的联合主键

## # 关系代数-函数依赖-范式

#### 关系代数
假设有表：s1 和 s2
1. 并、交、差
2. 笛卡尔积（符号就是乘号）：s1*s2，结果表：两个表的所有字段，s1中的每条记录依次和s2中所有记录组合成一条记录（注意重复的也会组合，这就是和“并”不同的地方）
3. 投影（符号是派（Π））：实际是按条件选择某关系模型中的某列，列也可以用数字表示
4. 选择（符号是sigma，O的右上角多一点）：实际是按条件选择某关系模式中的某条记录
5. 自然连接（符号是两个三角形连接起来）：显示全部的属性，但是相同属性只显示一次，显示两个关系模式中属性相同且值相同的记录

#### 函数依赖
给定一个x，能唯一确定一个y，就称x确定y，或者说y依赖于x，例如：y=x*x函数。

1. 函数依赖又可以扩展为两种规则：
- -- 部分依赖：A可以确定C，B也可以确定C，即：（A,B） -> C
- -- 传递依赖：A->B->C，A->B,B->C，则：A->C

2. 键（有时称码）
- -- 超键：能唯一标识此表的属性组合（如：学生表：学号、姓名、年龄，则能唯一标识此表的有：（学号）、（学号+姓名）、（学号+姓名+年龄）、（学号+年龄））
- -- 候选键：超键中去掉冗余的属性，剩余的属性就是候选键（如：学生表：学号、姓名、年龄、身份证，候选键有：（学号）、（身份证）、（学号、身份证））
- -- 主键：任选一个候选键，即可作为主键（如：学生表：学号、姓名、年龄、身份证，候选键有：（学号）、（身份证）、（学号、身份证），任选一个候选键作为主键即可）
- -- 外键：其他表中的主键
- -- 主属性：候选键内的属性为主属性，其他属性为非主属性
- -- （如：学生表：学号、姓名、年龄、身份证，候选键有：（学号）、（身份证）、（学号、身份证），主属性有：学号、身份证，非主属性有：姓名、年龄）

3. 约束
- -- 实体完整性约束：即主键约束，主键不能为空，也不能重复。
- -- 参照完整性约束：即外键约束，外键必须是其他表中的已经存在的主键值，或者为空
- -- 用户自定义完整性约束：自定义表达式约束，如设定年龄属性的值必须在0到150之间

#### 范式（重要）
1. 第一范式（1NF）
关系中的每一个分量必须是一个不可分的数据项。（通俗讲就是，第一范式就是表中不允许有小表的存在）

2. 第二范式(2NF)（主要消除部分依赖）（注意：第二范式主要是针对复合主键的，对于单属性主键（只有单个属性，不存在部分依赖），每个属性一定是满足2NF的）

如果关系R属于第一范式（1NF），且每一个非主属性完全函数依赖于任何一个候选码（也就是候选键），则R属于2NF。
通俗讲就是，2NF就是在1NF的基础上，表中的每一个非主属性不会只依赖复合主键中的某一个列，而是完全依赖（消除部分依赖）

例如：选课表：（学号，课程号，成绩，学生姓名）
主键是联合主键（学号，课程号）非主属性：成绩，学生姓名

其中学生姓名就不符合2NF，因为学生姓名只依赖于学号，属于部分依赖于主键，不符合2NF


3. 第三范式（3NF）（主要消除传递依赖）
在满足1NF的基础上，表中不存在非主属性对主键的传递依赖

例如：学生表：（学号，学生姓名，系编号，系名，系主任）
主键是联合主键（学号）非主属性：学生姓名，系编号，系名，系主任

其中：学号 -> 系编号 -> 系名，系主任  （属于传递依赖，不符合第三范式）

4. 第四范式

5. 第五范式

6. bc范式（当有多个候选键时（注意每个候选键可以是一个属性，也可以是多个属性组成））
是指在第三范式的基础上进一步消除主属性对于主键的部分函数依赖和传递依赖。

通俗讲就是，在每一种情况下，每一个依赖的左边决定因素都必然包含候选键。

#### 候选键的求法
根据依赖集，1.找出从未在右边出现过的属性，必然是候选键之一，2.以该属性为基础，根据依赖集依次扩展，看能否遍历所有属性，将无法遍历的加入候选键中，直到能推出所有属性为止，这个时候就形成了一个候选键

## # 模式分解
范式之间的转换一般都是通过拆分属性，即模式分解，将具有部分函数依赖和传递依赖的属性分离出来，来达到一步步优化，一般分为以下两种：

#### 保持函数依赖分解
1. 对于关系模式R，有依赖集F，若对R进行分解，分解出来的多个关系模式，保持原来的依赖集不变，则为保持函数依赖的分解。另外，注意要消除掉冗余依赖（如传递依赖）

2. 判断保持依赖的方法（软考，就根据第一步判断就行了，很少考第二步）
- -- 第一步：如果F上的每一个函数依赖都在其分解的某一个关系上成立，则这个分解是保持依赖（这个个充分条件，也就是光靠这个条件，有可能得出不了答案）。简单的方法就是，看每个函数依赖的左右两边属性是否都在同一个分解的模式中。

- -- 第二步：如果上面的方法判断失败，并不能断言分解不是保持依赖，还要使用下面的通用方法来做进一步判断：
- -- -- 对F上的每一个α->β使用下面的过程：
- -- -- result:=α；
- -- -- while(result发生变化) do
- -- -- for each 分解后的Ri
- -- -- t=(result ∩ Ri)+ ∩ Ri
- -- -- result=result ∪ t

#### 无损分解
1. 概念：分解后的关系模式能够还原出原关系模式，就是无损分解，不能还原就是有损。

2. 判断方法：当分解为两个关系模式，可以通过以下定理判断是否无损分解：
- -- 如果R的分解为p={R1,R2}，F为R所满足的函数依赖集合，分解p具有无损连接性的充分必要条件是R1 ∩ R2 -> (R1-R2)或者R1 ∩ R2 -> (R2-R1)
3. 当分解为三个及以上关系模式时，可以通过表格法求解。（首先是建原始表格：表格列是原始关系模型所有属性，行是拆分出来的新关系模式，每个格子是该关系模式是否包含该属性；其次是根据题目给的函数依赖来判断每个打叉的格子能否通过打勾的格子来推导出来，只要某一行能推导出来，就是无损分解，否则是有损分解）（多看视频多理解）

#### 并发控制
 
 ACID

 三个问题：

 1. 丢失更新

 2. 不可重复读

 3. 脏读

#### 三级封锁协议

 1. 一级封锁协议：事务在改数据R之前必须先对其加X锁（即写锁或者叫排它锁），直到事务结束才释放。可以解决丢失更新的问题

 2. 二级封锁协议：一级封锁协议的基础上加上事务T在读数据R之前必须先对其加S锁（即读锁或者叫共享锁），读完后即可释放S锁，可以解决丢失更新、读脏数据问题。

 3. 三级封锁协议：一级封锁协议加上事务T在读取数据R之前先对其加S锁，直到事务结束才释放，可解决丢失更新、读脏数据、数据不可重复度问题。

#### 数据库安全


#### 分布式数据库

分片模式：

1. 水平分片：将表中水平的记录分别存放在不同的地方

2. 垂直分片：将表中的垂直的列值分别存放在不同的地方

分布透明性：

1. 分片透明性：用户或者应用程序不需要知道逻辑上访问的表具体是如何分块存储的

2. 位置透明性：应用程序不关心数据存储物理位置的改变

3. 逻辑透明性：用户或者应用程序无需知道局部使用的是哪种数据模型

4. 复制透明性：用户或者应用程序不关心复制的数据从何而来

#### 数据仓库
数据仓库是一个面向主题的、集成的、非易失的、且随时间变化的数据集合，用于支持管理决策。

数据仓库的结构通常包含四个层次：

1. 数据源：是数据仓库系统的基础，是整个系统的数据源泉

2. 数据的存储与管理：是整个数据仓库系统的核心

3. OLAP（联机分析处理）服务器：对分析需要的数据进行有效集成，按多维模型组织，以便进行多角度、多层次的分析，并发现趋势。

4. 前端工具：主要包括各种报表工具、查询工具、数据分析工具、数据挖掘工具以及各种基于数据仓库或者数据集市的应用开发工具。 

BI系统主要包括数据预处理、建立数据仓库、数据分析和数据展现四个主要阶段。

数据预处理是整合企业原始数据的第一步，它包括数据的抽取（Extraction）、转换（Transformation）和加载（Load）三个过程（ETL过程）；

建立数据仓库则是处理海量数据的基础；

数据分析是体现系统智能的关键，一般采用联机分析处理（OLAP）和数据挖掘两大技术。

## # 数据库反规范化技术（主要规范化与反规范化都是在逻辑结构设计阶段进行的）
反规范化技术：规范化设计后，数据库设计者希望牺牲部分规范化来提高性能。

1. 采用反规范化技术的益处：降低连接操作的需求、降低外码和索引的数目，还可能减少表的数目，能够提高查询效率。
2. 可能带来的问题：数据的重复存储，浪费了磁盘空间；可能出现数据的完整性问题，为了保障数据的一致性，增加了数据维护的复杂性，会降低修改速度。

3. 具体方法：
- -- 增加冗余列：在多个表中保留相同的列，通过增加数据冗余减少或避免查询时的连接操作。
- -- 增加派生列：在表中增加可以由本表或者其它表中数据计算生成的列，减少查询时的连接操作并避免计算或者使用集合函数。
- -- 重新组表：如果许多用户需要查看两个表连接出来的结果数据，则把这两个表重新组成一个表来减少连接而提高性能。
- -- 水平分割表：根据一列或者多列数据的值，把数据放到多个独立的表中，主要用于表数据规模很大、表中数据相对独立或数据需要存放到多个介质上时使用。
- -- 垂直分割表：对表进行分割，将主键或者部分列放到一个表中，主键与其它列放到另一个表中，在查询时减少I/O次数。


## # 非关系型数据库
常见的NoSQL数据库通过存储方式划分，可分为
1. 文档存储：web应用，存储面向文档和半结构化数据，代表：MongoDB
2. 键值存储L: Reids、Memcached等
3. 列存储：（注意关系型数据库中，增删改都是操作行，查是针对列），列存储是按列存储，有利于查询，增删改效力低，常用于分布式数据存储和管理，如HBase、BigTable等
4. 图存储：应用场景主要是社交网络、推荐系统、专注于构建系统图谱，如：Neo4j、OrientDB等

## # sql语言

select ... from 表名1,表名2... where 条件

select ...(这里对应投影) from 表名1,表名2（做的是笛卡尔积）where ...（这里对应选择）

```注意from后面使用逗号跟多个表名时，做的是笛卡尔积，非常不利于查询```

当有聚集函数时，通常来说肯定是需要分组的，即 group by 后面接按照那一列来进行分组；
分组的select后面只能接分组的列和聚合函数的结果，不能查其它列，否则报错

having：条件判断子句

distinct：过滤重复的选项，只保留一条记录

union： 出现在两个sql语句之间，将两个sql语句的查询结果取或运算（并），即值存在于第一句或第二句都会被选出。

intersect：对两个sql语句的查询结果做与运算（交），即值同时存在于两个语句才被选出。

min、avg、max：分组查询时的聚合函数

#### having 和 where 的区别
having 只会在分组的时候才会出现，因为需要对聚集函数做判断，如：select sno, avg(score) from student group by sno having(avg(score)>60)。
取平均分大于60的学生学号和平均分数

如果是对列的判断还是需要使用where  c、a、d、b